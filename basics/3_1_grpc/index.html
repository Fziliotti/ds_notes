<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  
  
  <link rel="shortcut icon" href="../../img/favicon.ico">
  <title>Estudo de Caso - gRPC - Sistemas Distribuídos</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700" />

  <link rel="stylesheet" href="../../css/theme.css" />
  <link rel="stylesheet" href="../../css/theme_extra.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" />
  
  <script>
    // Current page data
    var mkdocs_page_name = "Estudo de Caso - gRPC";
    var mkdocs_page_input_path = "basics/3_1_grpc.md";
    var mkdocs_page_url = null;
  </script>
  
  <script src="../../js/jquery-2.1.1.min.js" defer></script>
  <script src="../../js/modernizr-2.8.3.min.js" defer></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script> 
  
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
        <a href="../.." class="icon icon-home"> Sistemas Distribuídos</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../..">Prólogo</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="" href="../../intro/intro.md">None</a>
                    </li>
                </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../..">Sistemas Distribuídos</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../..">Docs</a> &raquo;</li>
    
      
    
    <li>Estudo de Caso - gRPC</li>
    <li class="wy-breadcrumbs-aside">
      
    </li>
  </ul>
  
  <hr/>
</div>
          <div role="main">
            <div class="section">
              
                <h1 id="estudo-de-caso-rpc-grpc">Estudo de Caso RPC: gRPC</h1>
<p>gRPC é um framework para invocação remota de procedimentos multi-linguagem e sistema operacional, usando internamente pelo Google há vários anos para implementar sua arquitetura de micro-serviços.
Inicialmente desenvolvido pelo Google, o gRPC é hoje de código livre encubado pela Cloud Native Computing Foundation.</p>
<p>O sítio <a href="https://grpc.io">https://grpc.io</a> documenta muito bem o gRPC, inclusive os <a href="https://grpc.io/blog/principles/">princípios</a> que nortearam seu projeto.</p>
<p>O seu uso segue, em linhas gerais, o modelo discutido nas seções anteriores, isto é, inicia-se pela definição de estruturas de dados e serviços, "compila-se" a definição para gerar stubs na linguagem desejada, e compila-se os stubs juntamente com os códigos cliente e servidor para gerar os binários correspondentes.
Vejamos a seguir um tutorial passo a passo, em Java, baseado no <a href="https://grpc.io/docs/quickstart/java.html">quickstart guide</a>.</p>
<h2 id="instalacao">Instalação</h2>
<p>Os procedimentos de instalação dependem da linguagem em que pretende usar o gRPC, tanto para cliente quanto para servidor.
No caso do <strong>Java</strong>, <strong>não há instalação propriamente dita</strong>.</p>
<h2 id="exemplo-java">Exemplo Java</h2>
<p>Observe que o repositório base apontado no tutorial serve de exemplo para diversas linguagens e diversos serviços, então sua estrutura é meio complicada. Nós nos focaremos aqui no exemplo mais simples, uma espécie de "hello word" do RPC.</p>
<h3 id="pegando-o-codigo">Pegando o código</h3>
<p>Para usar os exemplos, você precisa clonar o repositório com o tutorial, usando o comando a seguir.</p>
<pre><code class="bash">git clone -b v1.19.0 https://github.com/grpc/grpc-java
</code></pre>

<p>Uma vez clonado, entre na pasta de exemplo do Java e certifique-se que está na versão 1.19, usada neste tutorial.</p>
<pre><code class="bash">cd grpc-java\examples
git checkout v1.19.0
</code></pre>

<h3 id="compilando-e-executando">Compilando e executando</h3>
<p>O projeto usa <a href="https://gradle.org/">gradle</a> para gerenciar as dependências. Para, use o <em>wrapper</em> do gradle como se segue.</p>
<pre><code class="bash">./gradlew installDist
</code></pre>

<p>Caso esteja na UFU, coloque também informação sobre o proxy no comando.</p>
<pre><code class="bash">./gradlew -Dhttp.proxyHost=proxy.ufu.br -Dhttp.proxyPort=3128 -Dhttps.proxyHost=proxy.ufu.br -Dhttps.proxyPort=3128 installDist
</code></pre>

<p>Como quando usamos sockets diretamente, para usar o serviço definido neste exemplo, primeiros temos que executar o servidor.</p>
<pre><code class="bash">./build/install/examples/bin/hello-world-server
</code></pre>

<p>Agora, em <strong>um terminal distinto</strong> e a partir da mesma localização, execute o cliente, quantas vezes quiser.</p>
<pre><code class="bash">./build/install/examples/bin/hello-world-client
</code></pre>

<h3 id="o-servico">O serviço</h3>
<p>O exemplo não é muito excitante, pois tudo o que o serviço faz é enviar uma saudação aos clientes.
O serviço é definido no seguinte arquivo <code>.proto</code>, localizado em <code>./src/main/proto/helloworld.proto</code>.</p>
<pre><code class="protobuf">message HelloRequest {
  string name = 1;
}

message HelloReply {
  string message = 1;
}


// The greeting service definition.
service Greeter {
  rpc SayHello (HelloRequest) returns (HelloReply) {}
}
</code></pre>

<p>No arquivo, inicialmente são definidas duas mensagens, usadas como requisição (cliente para servidor) e outra como resposta (servidor para cliente) do serviço definido em seguida.</p>
<p>A mensagem <code>HelloRequest</code> tem apenas um campo denominado <code>name</code>, do tipo <code>string</code>. Esta mensagem conterá o nome do cliente, usado na resposta gerada pelo servidor.</p>
<p>A mensagem <code>HelloReply</code> também tem um campo do tipo <code>string</code>, denominado <code>message</code>, que conterá a resposta do servidor.</p>
<p>O serviço disponível é definido pela palavra chave <code>service</code>e de nome <code>Greeter</code>; é importante entender que este nome será usado em todo o código gerado pelo compilador gRPC e que se for mudado, todas as referências ao código gerado devem ser atualizadas.</p>
<p>O serviço possui apenas uma operação, <code>SayHello</code>, que recebe como entrada uma mensagem <code>HelloRequest</code> e gera como resposta uma mensagem <code>HelloReply</code>.
Caso a operação precisasse de mais do que o conteúdo de <code>name</code> para executar, a mensagem <code>HelloRequest</code> deveria ser estendida, pois não há passar mais de uma mensagem para a operação.
Por outro lado, embora seja possível passar zero mensagens, esta não é uma prática recomendada.
Isto porquê caso o serviço precisasse ser modificado no futuro, embora seja possível estender uma mensagem, não é possível modificar a assinatura do serviço. 
Assim, caso não haja a necessidade de se passar qualquer informação para a operação, recomenda-se que seja usada uma mensagem de entrada vazia, que poderia ser estendida no futuro.
O mesmo se aplica ao resultado da operação.</p>
<p>Observe também que embora o serviço de exemplo tenha apenas uma operação, poderia ter múltiplas.
Por exemplo, para definir uma versão em português da operação <code>SayHello</code>, podemos fazer da seguinte forma.</p>
<pre><code class="protobuf">message HelloRequest {
  string name = 1;
}

message HelloReply {
  string message = 1;
}

message OlaRequest {     // &lt;&lt;&lt;&lt;&lt;====
  string name = 1;
}

message OlaReply {       // &lt;&lt;&lt;&lt;&lt;====
  string message = 1;
}

service Greeter {
  rpc SayHello (HelloRequest) returns (HelloReply) {}
  rpc DigaOla (OlaRequest) returns (OlaReply) {}// &lt;&lt;&lt;&lt;&lt;====
}
...
</code></pre>

<p>Observe que a nova operação recebe como entrada  mensagens <code>OlaRequest</code> e <code>OlaReply</code>, que tem definições exatamente iguais a <code>HellorRequest</code> e <code>HelloReply</code>.
Logo, em vez de definir novas mensagens, poderíamos ter usado as já definidas. Novamente, esta não é uma boa prática, pois caso fosse necessário evoluir uma das operações para atender a novos requisitos e estender suas mensagens, não será necessário tocar o restante do serviço.
Apenas reforçando, é boa prática definir <em>requests</em> e <em>responses</em> para cada método, a não ser que não haja dúvida de que serão para sempre iguais.</p>
<h3 id="implementando-um-servico">Implementando um serviço</h3>
<p>Agora modifique o arquivo <code>.proto</code> como acima, para incluir a operação <code>DigaOla</code>, recompile e reexecute o serviço.
Não dá certo, não é mesmo? Isto porquê você adicionou a definição de uma nova operação, mas não incluiu o código para implementá-la.
Façamos então a modificação do código, começando por <code>./src/main/java/io/grpc/examples/helloworld/HelloWorldServer.java</code>.
Este arquivo define a classe que <strong>implementa</strong> o serviço <code>Greeter</code>, <code>GreeterImpl</code>, com um método para cada uma das operações definidas. 
Para confirmar, procure por <code>sayHello</code>para encontrar a implementação de <code>SayHello</code>; observe que a diferença do <code>casing</code> vem das boas práticas de Java, de definir métodos e variáveis em <em>Camel casing</em>.</p>
<p>Para que sua versão estendida do serviço <code>Greeter</code> funcione, defina um método correspondendo à <code>DigaOla</code>, sem consultar o código exemplo abaixo, mas usando o código de <code>sayHello</code> como base; não se importe por enquanto com os métodos sendo invocados.
Note que os <code>...</code> indicam que parte do código, que não sofreu modificações, foi omitido.</p>
<pre><code class="java">...
private class GreeterImpl extends GreeterGrpc.GreeterImplBase {
...

  @Override
  public void sayHello(HelloRequest req, StreamObserver&lt;HelloReply&gt; responseObserver) {
      ...
  }

  @Override
  public void digaOla(OlaRequest req, StreamObserver&lt;OlaReply&gt; responseObserver) {
    OlaReply reply = 
      OlaReply.newBuilder().setMessage(&quot;Ola &quot; + req.getName()).build();
    responseObserver.onNext(reply);
    responseObserver.onCompleted();
  }
}
</code></pre>

<p>Se você recompilar e reexecutar o código, não perceberá qualquer mudança na saída do programa. Isto porquê embora tenha definido um novo serviço, você não o utilizou. Para tanto, agora modifique o cliente, em <code>src/main/java/io/grpc/examples/helloworld/HelloWorldClient.java</code>, novamente se baseando no código existente e não se preocupando com "detalhes".</p>
<pre><code class="java">public void greet(String name) {
  logger.info(&quot;Will try to greet &quot; + name + &quot; ...&quot;);
...
  OlaRequest request2 = OlaRequest.newBuilder().setName(name).build();
  OlaReply response2;
  try {
    response2 = blockingStub.digaOla(request2);
  } catch (StatusRuntimeException e) {
    logger.log(Level.WARNING, &quot;RPC failed: {0}&quot;, e.getStatus());
   return;
  }
  logger.info(&quot;Greeting: &quot; + response2.getMessage());
}
</code></pre>

<p>Agora sim, você pode reexecutar cliente e servidor.</p>
<pre><code class="bash">./gradlew installDist
./build/install/examples/bin/hello-world-server &amp;
./build/install/examples/bin/hello-world-client
</code></pre>

<p>Percebeu como foi fácil adicionar uma operação ao serviço? Agora nos foquemos nos detalhes.</p>
<h4 id="stub-do-servidor">Stub do servidor</h4>
<ul>
<li>Como criar o servidor</li>
<li>Como definir o serviço</li>
<li>Como "startar" o servidor.</li>
</ul>
<h4 id="stub-do-cliente">Stub do cliente</h4>
<ul>
<li>Stub bloqueante</li>
<li>Stub não bloqueante</li>
</ul>
<h4 id="idl-grpc">IDL gRPC</h4>
<p>Outras características da IDL do gRPC</p>
<ul>
<li>Tipos básicos</li>
<li>bool: boolean (true/false)</li>
<li>double: 64-bit; ponto-flutuante </li>
<li>float: 32-bit; ponto-flutuante </li>
<li>i32: 32-bit; inteiro sinalizado </li>
<li>i64: 64-bit; inteiro sinalizado</li>
<li>siXX: signed</li>
<li>uiXX: unsigned</li>
<li>sfixedXX: codificação de tamanho fixo</li>
<li>bytes: 8-bit; inteiro sinalizado</li>
<li>string: string UTF-8 ou ASCII 7-bit</li>
<li>
<p>Any: tipo indefinido</p>
</li>
<li>
<p><a href="https://developers.google.com/protocol-buffers/docs/proto3">Diferentes traduções</a></p>
</li>
<li>
<p>Coleções
Defina e implemente uma operação <code>DigaOlas</code> em que uma lista de nomes é enviada ao servidor e tal que o servidor responda com uma longa string cumprimentando todos os nomes, um ap;os o outro.</p>
</li>
<li>
<p><em>Streams</em></p>
</li>
<li>Do lado do servidor</li>
</ul>
<p>```java
   List<String> listOfHi = Arrays.asList("e aih", "ola", "ciao", "bao", "howdy", "s'up");</p>
<p>@Override
   public void digaOlas(OlaRequest req, StreamObserver<OlaReply> responseObserver) {
   for (String hi: listOfHi)
   {
     OlaReply reply = OlaReply.newBuilder().setMessage(hi + ", " req.getName()).build();
     responseObserver.onNext(reply);
   }
   responseObserver.onCompleted();
   }
  ```
  - Do lado do cliente</p>
<p><code>java
   OlaRequest request = OlaRequest.newBuilder().setName(name).build();
   try {
       Iterator&lt;OlaReply&gt; it = blockingStub.digaOlas(request);
       while (it.hasNext()){
         OlaReply response = it.next();
         logger.info("Greeting: " + response.getMessage());
       }
    } catch (StatusRuntimeException e) {
       logger.log(Level.WARNING, "RPC failed: {0}", e.getStatus());
       return;
    }</code></p>
<h2 id="exemplo-python">Exemplo Python</h2>
<pre><code class="bash">apt-get install python3
apt-get install python3-pip
python3 -m pip install --upgrade pip
python3 -m pip install grpcio
python3 -m pip install grpcio-tools

git clone -b v1.10.x https://github.com/grpc/grpc
cd grpc/examples/python/helloworld
python3 greeter\_server.py
python3 greeter\_client.py
</code></pre>

<p>Para recompilar os stubs, faça</p>
<pre><code class="bash">python3 -m grpc_tools.protoc -I../../protos --python_out=. --grpc_python_out=. ../../protos/helloworld.proto
</code></pre>

<p>Modifique o servidor</p>
<pre><code class="Python">def DigaOla(self, request, context):
    return helloworld_pb2.OlaReply(message='Ola, %s!' + request.name)
</code></pre>

<p>Modifique o cliente</p>
<pre><code class="Python">response = stub.DigaOla(helloworld_pb2.OlaRequest(name='zelelele'))
print(&quot;Greeter client received: &quot; + response.message)
</code></pre>
              
            </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
      
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="versions">
    <span class="rst-current-version" data-toggle="rst-current-version">
      
      
      
    </span>
</div>
    <script>var base_url = '../..';</script>
    <script src="../../js/theme.js" defer></script>
      <script src="../../search/main.js" defer></script>
    <script defer>
        window.onload = function () {
            SphinxRtdTheme.Navigation.enable(true);
        };
    </script>

</body>
</html>
