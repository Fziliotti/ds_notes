<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  
  
  <link rel="shortcut icon" href="../img/favicon.ico">
  <title>Comunicação - Sistemas Distribuídos</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700" />

  <link rel="stylesheet" href="../css/theme.css" />
  <link rel="stylesheet" href="../css/theme_extra.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" />
  
  <script>
    // Current page data
    var mkdocs_page_name = "Comunica\u00e7\u00e3o";
    var mkdocs_page_input_path = "basics/index.md";
    var mkdocs_page_url = null;
  </script>
  
  <script src="../js/jquery-2.1.1.min.js" defer></script>
  <script src="../js/modernizr-2.8.3.min.js" defer></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script> 
  
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
        <a href=".." class="icon icon-home"> Sistemas Distribuídos</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="..">Prólogo</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../intro/">Introdução</a>
                    </li>
                </ul>
                <ul class="current">
                    <li class="toctree-l1 current"><a class="reference internal current" href="./">Comunicação</a>
    <ul class="current">
    </ul>
                    </li>
                </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="..">Sistemas Distribuídos</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="..">Docs</a> &raquo;</li>
    
      
    
    <li>Comunicação</li>
    <li class="wy-breadcrumbs-aside">
      
    </li>
  </ul>
  
  <hr/>
</div>
          <div role="main">
            <div class="section">
              
                <h2 id="a-pedra-fundamental-da-construcao-de-sistemas-distribuidos-e-a-capacidade-de-comunicacao-entre-processos-via-um-canal-de-comunicacao">A pedra fundamental da construção de sistemas distribuídos é a capacidade de comunicação entre processos via um canal de comunicação.</h2>
<p>layout: default
title: Sockets
parent: Comunicação
nav_order: 1</p>
<hr />
<p>O desenvolvimento de qualquer sistema distribuído requer a capacidade de componentes deste sistema "conversar" uns com os outros.
Para que a conversa aconteça, são necessários um <strong>canal de comunicação</strong> e um <strong>protocolo de comunicação</strong>.</p>
<p>O canal de comunicação é o meio pelo qual os elementos da conversa são transmitidos e o protocolo são as regras codificam tal conversa.
Por exemplo, quando você fala com uma pessoa, cara a cara, o meio de comunicação é o ar, e o protocolo utilizado é a linguagem escolhida, Português por exemplo, e os sinais usados para indicar quando um ou outro quer ou pode falar.</p>
<p>Quanto aos canais de comunicação, estes podem ter diversas formas:</p>
<hr />
<ul>
<li>Ponto-a-ponto</li>
<li>Eficiente</li>
<li>Caro para muitos nós</li>
<li>Roteamento trivial</li>
<li>Compartilhado</li>
<li>Colisões</li>
<li>Menor custo</li>
<li>Roteamento mais complicado</li>
</ul>
<hr />
<p>Nas redes atuais, pode se dizer que o meio mais utilizado é provido pela arquitetura <strong>Ethernet</strong>, que trata da comunicação nós usando um barramento compartilhado.
Sobre este meio, são usados protocolos para, por exemplo,</p>
<hr />
<ul>
<li>Acesso ao meio </li>
<li>Transmissão de mensagens</li>
<li>Se evitar e tratar colisões</li>
</ul>
<hr />
<p>As redes Ethernet, contudo, cobrem pequenas áreas, e para se ter conversas "mais interessantes", é necessário se conecte diversas destas redes.
A conversa então é feita por meio de intermediários, permitindo que mensagens de um interlocutor sejam <strong>roteadas</strong> para o outro, via tais intermediários.
Um exemplo interessante das questões ligadas à manutenção da conversa entre dois pontos é a decisão Packet Switching x Circuit Switching:</p>
<hr />
<ul>
<li>Packet Switching</li>
<li>Dados divididos em pacotes</li>
<li>Cada pacote viaja independentemente</li>
<li>Pacotes são perdidos</li>
<li>Latência variável</li>
<li>Circuit switching</li>
<li>Caminho dedicado</li>
<li>Recursos reservados</li>
<li>Pacotes de tamanho fixo</li>
<li>Latência constante</li>
</ul>
<hr />
<p>Outra questão é quanto à confiabilidade na transmissão dos elementos da conversa, isto é, se a rede deve garantir ou não que uma algo "dito" por um interlocutor deve garantidamente ser "ouvido"  pelo outro, ou se a mensagem pode ser perdida no meio.</p>
<p>Felizmente boa parte da complexidade da resolução destas questões é abstraída do desenvolvedor (<strong>você</strong>) dos sistemas distribuídos, lhe cabendo apenas a decisão de qual protocolo utilizar. 
Nas redes atuais, a conversa em componentes será feita, em algum nível, por meio dos protocolos da arquitetura <strong>Internet</strong>.</p>
<hr />
<ul>
<li>Internetworking Protocol</li>
<li>Redes subjacentes são abstraídas</li>
<li>Melhor esforço</li>
<li>Roteadores conectam as redes.</li>
</ul>
<hr />
<h1 id="a-internet">A Internet</h1>
<p><img alt="A Internet" src="images/network.png" /></p>
<p><img alt="image" src="images/04-01.png" /></p>
<p>Cada camada conversa com a equivalente do outro lado. Na prática, a comunicação desce e sobe a pilha. Cada camada é responsável por:</p>
<ul>
<li>Bits</li>
<li>Frames/quadros; controle de fluxo; acesso ao meio.</li>
<li>Datagramas/pacotes; roteamento</li>
<li>Controle de fluxo; fim a fim; confiabilidade; tcp e udp</li>
<li>Streams/fluxos; conexões lógicas; restart; checkpoint; http, ssl</li>
<li>Objetos; json, xml; criptografia</li>
<li>Aplicações; http, pop, ftp</li>
<li>Headers das camadas superiores são dados nas camadas inferiores</li>
</ul>
<hr />
<h6 id="osi-x-internet">OSI x Internet</h6>
<p><a href="http://computing.dcu.ie/~humphrys/Notes/Networks/intro.2.html"><img alt="OSI x IP" src="images/osi-ip.jpg" /></a></p>
<hr />
<p>Internet Protocol
* Bibliotecas/middleware provêm o restante das funcionalidades
  * (De)Serialização
    * Nomeamento
    * Criptografia
    * Replicação
    * Invocação remota de procedimentos
    * ...</p>
<hr />
<h2 id="sockets">Sockets</h2>
<ul>
<li>Hosts</li>
<li>Cada interface tem um endereço MAC \pause -- Somente comunicação direta</li>
<li>Cada interface tem um endereço IPv4/IPv6 \pause -- 32 x 128 bits</li>
<li>
<p>Como falar com uma aplicação?</p>
</li>
<li>
<p>Sockets</p>
</li>
<li>Pontos finais da comunicação</li>
<li>Porta: 16 bits<ul>
<li><a href="http://www.iana.org">IANA</a> (Internet Assigned Numbers Authority)</li>
<li>Bem conhecidas -- 0-1023</li>
<li>Proprietárias -- 49151<ul>
<li>Dinâmicas -- 65535</li>
</ul>
</li>
</ul>
</li>
<li>Domínio: AF_INET (Internet), PF_UNIX, PF_X25..., PF_INET (Internet)</li>
<li>Tipo: SOCK_STREAM x SOCK_DGRAM (TCP x UDP)</li>
<li>Utilizado como um arquivo</li>
<li>Protocolo: por sua conta</li>
</ul>
<hr />
<hr />
<p><img alt="image" src="images/04-15.png" /></p>
<hr />
<h3 id="exemplo-tcp">Exemplo - TCP</h3>
<p>O seguinte arquivo pode ser nomeado, por exemplo, <code>server.py</code>, mas não pode, de forma alguma, ser nomeado <code>socket.py</code>.</p>
<pre><code class="Python">#server.py
#!/usr/bin/python                               # This is server.py file

import socket                                   # Import socket module

s = socket.socket()                             # Create a socket object
host = socket.gethostname()                # Get local machine name
port = 12345                                    # Reserve a port for your service.
s.bind((host, port))                            # Bind to the port

s.listen(5)                                     # Now wait for client connections.
while True:
   c, addr = s.accept()                         # Establish connection with client.
   print('Got connection from', addr)
   c.send('Thank you for connecting'.encode())
   c.close()                                    # Close the connection
</code></pre>

<p>Para executá-lo, faça</p>
<pre><code class="bash">python server.py
</code></pre>

<p>em um terminal e em outro faça</p>
<pre><code class="bash">telnet localhost 12345
# ou
netcat localhost 12345
</code></pre>

<p>Em Java, a criação do socket seria muito mais simples, consistindo apenas em: </p>
<pre><code class="Java">...
Socket s = new ServerSocket(port);
...
</code></pre>

<p>Do lado cliente, estabelece-se uma conexão apontando-se para onde está o servidor.</p>
<pre><code class="Python">#client.py

#!/usr/bin/python                               # This is client.py file

import socket                                   # Import socket module

s = socket.socket()                             # Create a socket object
host = socket.gethostname()                # Get local machine name
port = 12345                                    # Reserve a port for your service.

s.connect((host, port))
data = s.recv(1024)
print(data.decode())
s.close()                                         # Close the socket when done
</code></pre>

<p>E para se executar o cliente, faça:</p>
<pre><code class="bash">python client.py
</code></pre>

<p>O cliente em Java também é simplificado.</p>
<pre><code class="Java">...
Socket s = new Socket(hostname,port);
...
</code></pre>

<p>Observe que o <code>socket.close()</code> encerra a conexão do lado de quem invoca. Na contraparte, invocações a <code>socket.recv()</code> retornam com 0 bytes lidos.</p>
<h3 id="exercicio-ping-pong">Exercício: Ping-Pong</h3>
<p>Modifique cliente e servidor tal que o cliente envie uma mensagem passada na linha de comando ao servidor e fique esperando uma resposta, e tal que o servidor fique esperando uma mensagem e então solicite ao operador que digite uma resposta e a envie para o cliente. O loop continua até que o usuário digite SAIR, e a conexão seja encerrada.</p>
<pre><code class="bash">#Terminal 1
python server.py
Esperando conexão.
Esperando mensagem.
Mensagem recebida: lalala
Digite resposta: lelele
Resposta enviada.
Conexão encerrada.
Esperando conexão.

#Terminal 2
python client.py
Digite mensagem: lalala
Mensagem enviada.
Esperando resposta.
Resposta recebida: lelele
Digite mensagem: SAIR
Desconectando.
</code></pre>

<p>Observe que para ler do teclado em Python 2 você deve usar <code>x = raw_input()</code>, enquanto que em Python 3 seria <code>x = input()</code>. Além disso, em Python, você deve remover as invocações para <code>encode</code> e <code>decode</code>.</p>
<h3 id="udp">UDP</h3>
<p>No exemplo anterior, usamos o protocolo TCP (o padrão da API). Caso quiséssemos usar UDP, precisaríamos nos atentar a alguns detalhes.</p>
<p>A criação do socket é feita explicitando-se o uso de <strong>datagramas</strong>
* <code>s = socket.socket(socket.AF_INET,socket.SOCK_DGRAM)</code></p>
<p>Um servidor UDP não executa <code>listen</code> ou <code>accept</code> e, em Python, simplesmente executa <code>data, addr = sock.recvfrom(4096)</code> para receber o datagrama, onde
* <code>data</code> é o conteúdo recebido e<br />
* <code>addr</code> o endereço de quem enviou o datagrama.</p>
<p>Neste caso, um mesmo socket é usado para manter comunicação com múltiplos interlocutores. Para enviar uma resposta a um interlocutor em específico, <code>addr</code> é usado: <code>sent = sock.sendto(data, addr)</code>, onde <code>sent</code> é a quantidade de bytes enviados.</p>
<p>Além deste detalhe, outros são importantes:
* falta de ordem
* falta de confiabilidade
* menos dados lidos que enviados.
* mais dados lidos que enviados (pode acontecer no TCP)</p>
<p>Com tantas dificuldades para se usar o UDP, fica a questão: <strong>para que serve UDP?</strong></p>
<h3 id="exercicio-udp">Exercício - UDP</h3>
<p>Modifique o código do exercício anterior para usar UDP em vez de TCP na comunicação entre nós.</p>
<h3 id="referencias">Referências</h3>
<ul>
<li><a href="http://pymotw.com/2/socket/udp.html">UDP em Python</a></li>
<li><a href="http://www.tutorialspoint.com/python/python_networking.htm">UDP em Python</a></li>
</ul>
<h3 id="ip-multicast">IP-Multicast</h3>
<p>Imagine enviar os mesmos dados para múltiplos destinatários.
* Como lidar com retransmissões?
* Muito estado nos servidores
* Sobre uso da rede.</p>
<hr />
<h5 id="ip-multicast_1">IP-Multicast</h5>
<p><img alt="IP Multicast" src="images/ipmulticast.jpg" /></p>
<ul>
<li>UDP</li>
<li>Mensagem entregue a todos que se juntaram ao grupo.</li>
<li>Grupo identificado por IP Classe D (224.0.0.0-239.255.255.255)</li>
</ul>
<p><a href="http://www.dasblinkenlichten.com/understanding-ip-multicast/"><img alt="" src="images/ipmulticast2.png" /></a></p>
<hr />
<hr />
<h5 id="servidor-servidor">Servidor Servidor</h5>
<ul>
<li>Criar Socket UDP</li>
<li>Uní-lo a um grupo</li>
<li>Receber pacotes.</li>
</ul>
<hr />
<hr />
<h5 id="mreceiverjava">MReceiver.java</h5>
<pre><code class="Java">import java.io.*;
import java.net.*;

public class MReceiver {
  public static void main(String[] args) {
    byte[] inBuf = new byte[256];
    try {
      MulticastSocket socket = new MulticastSocket(8888);
      InetAddress address = InetAddress.getByName(&quot;224.2.2.3&quot;);
      socket.joinGroup(address);
      while (true) {
        DatagramPacket inPacket = new DatagramPacket(inBuf, inBuf.length);
        socket.receive(inPacket);
        String msg = new String(inBuf, 0, inPacket.getLength());
        System.out.println(&quot;From &quot; + inPacket.getAddress() + &quot; Msg : &quot; + msg);
      }
    }catch (IOException ioe) {
      System.out.println(ioe);
    }
  }
}
</code></pre>

<hr />
<hr />
<h5 id="msenderjava">MSender.java</h5>
<pre><code class="Java">import java.io.*;
import java.net.*;
public class MSender {
 public static void main(String[] args) {
  byte[] outBuf;
  final int PORT = 8888;
  try {
   DatagramSocket socket = new DatagramSocket();
   long counter = 0;
   while (true) {
    counter++;
    outBuf = (&quot;Multicast numero &quot; + counter).getBytes();
    InetAddress address = InetAddress.getByName(&quot;224.2.2.3&quot;);
    DatagramPacket outPacket = 
         new DatagramPacket(outBuf, outBuf.length, address, PORT);
    socket.send(outPacket);
    System.out.println(&quot;Server sends : &quot; + msg);
    try { Thread.sleep(500); }catch (InterruptedException ie) {}
   }
  } catch (IOException ioe) { System.out.println(ioe); }
 }
}
</code></pre>

<p><a href="lycog.com/programming/multicast-programming-java/">Multicast em Java</a></p>
<h3 id="multicast-ipv6">Multicast IPv6</h3>
<hr />
<blockquote>
<p>In IPv6, the left-most bits of an address are used to determine its type. For a multicast address, the first 8 bits are all ones, i.e. FF00::/8. Further, bit 113-116 represent the scope of the address, which can be either one of the following 4: Global, Site-local, Link-local, Node-local.</p>
<p>In addition to unicast and multicast, IPv6 also supports anycast, in which a packet can be sent to any member of the group, but need not be sent to all members.''</p>
</blockquote>
<p><a href="http://www.baeldung.com/java-broadcast-multicast">Fonte</a></p>
<hr />
<h3 id="exercicio">Exercício</h3>
<p>Modifique o código que desenvolveu em Python para que, em vez de usar "localhost' como endereço, use o endereço multicast 224.1.1.1.</p>
<hr />
<h5 id="multicast-server-em-python-3">Multicast Server -- Em Python (3)</h5>
<pre><code class="Python">import socket
import struct

MCAST_GRP = '224.1.1.1'
MCAST_PORT = 5007

sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM, socket.IPPROTO_UDP)
sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
sock.bind((MCAST_GRP, MCAST_PORT))
mreq = struct.pack(&quot;=4sl&quot;, socket.inet_aton(MCAST_GRP), socket.INADDR_ANY)
#4 bytes (4s) seguidos de um long (l), usando ordem nativa (=)

sock.setsockopt(socket.IPPROTO_IP, socket.IP_ADD_MEMBERSHIP, mreq)

while True:
    print(sock.recv(10240).decode())
</code></pre>

<p><a href="https://stackoverflow.com/questions/603852/multicast-in-python">Fonte</a></p>
<hr />
<hr />
<h5 id="multicast-client-em-python-3">Multicast Client -- Em Python (3)</h5>
<pre><code class="Python">import socket

MCAST_GRP = '224.1.1.1'
MCAST_PORT = 5007

sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM, socket.IPPROTO_UDP)
sock.setsockopt(socket.IPPROTO_IP, socket.IP_MULTICAST_TTL, 2)
sock.sendto(input().encode(), (MCAST_GRP, MCAST_PORT))
</code></pre>

<p><a href="https://stackoverflow.com/questions/603852/multicast-in-python">Fonte</a></p>
<h2 id="-">---</h2>
<p>layout: default
title: Multiprogramação
parent: Comunicação
nav_order: 2</p>
<hr />
<h1 id="multiprogramacao-e-multithreading-em-sistemas-distribuidos">Multiprogramação e <em>Multithreading</em> em Sistemas Distribuídos</h1>
<p>É impossível pensar em sistemas distribuídos sem pensar em concorrência na forma de múltiplos processos executando, normalmente, em hosts distintos.
De fato, os exemplos que apresentamos até agora consistem todos em um processo cliente requisitando ações de algum processo servidor.
Apesar disso, a interação entre tais processos aconteceu sempre de forma sincronizada, <em>lock-step</em>, em que o cliente requisitava o serviço e ficava bloqueado esperando a resposta do servidor, para então prosseguir em seu processamento. O servidor, de sua parte, fica bloqueado esperando requisições, que atende e então volta a dormir.
Assim, apesar do uso de processadores distintos e da concorrência na execução dos processos, temos um baixo grau de efetivo paralelismo.</p>
<p><img alt="Request/Response" src="images/02-03.png" /></p>
<p>Para usarmos melhor os recursos disponíveis, uma das razões de ser da computação distribuída, temos então que pensar em termos eventos sendo disparados entre os componentes, que devem ser tratados assim que recebidos ou tão logo quanto haja recursos para fazê-lo. 
Estes eventos correspondem tanto a requisições quanto a respostas (efetivamente tornando difícil a distinção).
Além disso, sempre que possível, um componente não deve ficar exclusivamente esperando por eventos, aproveitando a chance executar outras tarefas até que eventos sejam recebidos.
Dada que processos interagem com a rede usando sockets, cuja operação de leitura é bloqueante, para aumentar a concorrência em um processo, precisamos falar de multi-threading.</p>
<p>Há duas razões claras para estudarmos multi-threading. A primeira, é a discutida acima: permitir o desenvolvimento de componentes que utilizem "melhormente" os recursos em um host.
A segunda é o fato que muitos dos problemas que aparecem em programação multi-thread, aparecem em programação multi-processo (como nos sistemas distribuídos), apenas em um grau de complexidade maior.</p>
<h2 id="threads-x-processos">Threads x Processos</h2>
<table>
<thead>
<tr>
<th>Processo</th>
<th>Thread</th>
</tr>
</thead>
<tbody>
<tr>
<td>Instância de um programa</td>
<td>"Processo leve"</td>
</tr>
<tr>
<td>Estado do processo</td>
<td>Estado do thread</td>
</tr>
<tr>
<td>Função main</td>
<td>"qualquer" função</td>
</tr>
<tr>
<td>Memória privada ao processo</td>
<td>Compartilha estado do processo que os contém</td>
</tr>
<tr>
<td>Código, Stack, Heap, descritores (e.g, file descriptors), controle de acesso</td>
<td>Stack, variáveis locais</td>
</tr>
<tr>
<td>IPC - Inter process communication</td>
<td>IPC -- Inter process communication</td>
</tr>
<tr>
<td>Sistema operacional</td>
<td>Diferentes implementações</td>
</tr>
<tr>
<td></td>
<td>Posix, C++, Java, ...</td>
</tr>
</tbody>
</table>
<h2 id="threads-em-sd">Threads em SD</h2>
<h3 id="cliente-multithreaded">Cliente multithreaded</h3>
<p>Vantagens similares a usar em sistemas centralizado.</p>
<ul>
<li>Lida com várias tarefas concorrentemente.</li>
<li>Esconde latência.</li>
<li>Separa código em blocos/módulos.</li>
</ul>
<hr />
<h3 id="servidor-multithreaded">Servidor multithreaded</h3>
<p>Há diversas possibilidades de uso de threads em servidores. A mais simples é usar apenas um, com temos feito até agora.</p>
<p><img alt="Single Threaded" src="images/singlethreadedserver.gif" /></p>
<hr />
<p>Outra opção é criar um novo tthread para cada nova requisição e atende múltiplas requisições concorrentemente.</p>
<p><img alt="Multi Threaded" src="images/multithreadedserver.gif" /></p>
<ul>
<li>Permite tratar requisições enquanto faz IO.</li>
<li>Número de threads é limitado. %Pelo framework em uso.</li>
<li>Número de threads deve ser limitado. %Para não saturar o servidor.</li>
<li>Criação e destruição de threads é cara.</li>
</ul>
<p>Assim, temos uma outra opção que também usa múltiplos threads, que usa <em>pools</em>  de threads para lidar com as requições.</p>
<p><a href="https://www3.nd.edu/~dthain/courses/cse30341/spring2009/project4/project4.html"><img alt="Pool Threaded" src="images/poolthreadedserver.gif" /></a></p>
<p>E se quebrarmos o processamento em vários pools, no que é conhecido como SEDA - <strong>Staged Event-Driven Architecture</strong>.</p>
<p><a href="http://images.cnitblog.com/blog/13665/201306/15180500-a54c8eb3d73246469f1b74ee74f2119b.png"><img alt="Seda" src="images/seda1.png" /></a></p>
<p>Assim, cada estágio pode ter seu próprio <em>pool</em>, que se escala individualmente.</p>
<p><a href="http://images.cnitblog.com/blog/13665/201306/15180500-a54c8eb3d73246469f1b74ee74f2119b.png"><img alt="Seda" src="images/seda2.png" /></a></p>
<p>Que lembra arquitetura de <a href="http://muratbuffalo.blogspot.com.br/2011/02/seda-architecture-for-well-conditioned.html">micro-serviços</a></p>
<p>Se você quiser ler mais sobre SEDA, vá <a href="http://courses.cs.vt.edu/cs5204/fall05-gback/presentations/SEDA_Presentation_Final.pdf">aqui</a>.</p>
<h3 id="problemas-com-multithreading">Problemas com multithreading</h3>
<p>Idealmente, os threads que compartilham variáveis seriam colocados nos mesmos processadores.
E se não houvesse compartilhamento e dado um número adequado de processadores, teríamos paralelismo perfeito.</p>
<p><img alt="Multithreaded" src="images/multithread2.png" /></p>
<p>A realidade, contudo, é outra e simplesmente criar múltiplos threads não garante paralelismo perfeito, pois o SO é quem é responsável por escalonar os mesmos.</p>
<p><img alt="Multithreaded" src="images/multithreaded.jpg" /></p>
<p>Memes bonitinhos à parte, precisamos enfrentar condições de corrida de forma a não levar <strong>inconsistências</strong>.</p>
<p><img alt="Multithreaded" src="images/multithread3.png" /></p>
<p>Para isso, usamos as primitivas de controle de concorrência que estudaram em SO, que também tem seus problemas em potencial, como <strong>deadlocks</strong> e <strong>inanição</strong>.
Veja o seguinte vídeo para uma análise detalhada do cenário anterior e outros pontos importantes.</p>
<iframe width="560" height="315" src="https://www.youtube.com/embed/JRaDkV0itbM" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

<h3 id="estado-em-servidores">Estado em Servidores</h3>
<h4 id="stateless-servers">Stateless Servers</h4>
<p>Não mantém informação após terminar de tratar requisições.</p>
<ul>
<li>Fecha todos os arquivos abertos</li>
<li>Não faz promessas de atualização ao cliente</li>
<li>
<p>Clientes e servidores são independentes</p>
</li>
<li>
<p>Pouca ou nenhuma inconsistência causada por falhas</p>
</li>
<li>Perda de desempenho (e.g., abertura do mesmo arquivo a cada requisição.)</li>
</ul>
<h4 id="stateful-servers">Stateful Servers</h4>
<p>Mantém informação dos clientes entre requisições.</p>
<ul>
<li>Mantem arquivos abertos</li>
<li>
<p>Sabe quais dados o cliente tem em cache</p>
</li>
<li>
<p>Possíveis inconsistência causada por falhas (cliente se conecta a servidor diferente)</p>
</li>
<li>
<p>Melhor desempenho</p>
</li>
<li>
<p>Maior consumo de recursos</p>
</li>
</ul>
<h4 id="impacto-na-concorrencia">Impacto na Concorrência</h4>
<table>
<thead>
<tr>
<th>Stateless</th>
<th>Stateful</th>
</tr>
</thead>
<tbody>
<tr>
<td>Resultado depende da entrada</td>
<td>Depende do histórico de entradas</td>
</tr>
<tr>
<td>Qualquer servidor pode atender</td>
<td>Mesmo servidor deve atender</td>
</tr>
</tbody>
</table>
<h2 id="multithread-na-pratica">Multithread na prática</h2>
<h3 id="pthreads">PThreads</h3>
<h4 id="funcao-de-entrada">Função de entrada</h4>
<pre><code class="c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;pthread.h&gt;

int thread_count;

void* hello(void* rank) {
    long my_rank = (long) rank;
    printf(&quot;Hello from thread %ld of %d\n&quot;, my_rank, thread_count);
    return NULL;
}
</code></pre>

<h4 id="criacao">Criação</h4>
<pre><code class="c">int main(int argc, char* argv[]) {
    long thread;
    pthread_t* thread_handles;

    if(argc &lt; 2) {
        printf(&quot;usage: %s &lt;number of threads&gt;&quot;, argv[0]); 
        return 1;
    }

    thread_count = strtol(argv[1], NULL, 10);
    thread_handles = malloc(thread_count*sizeof(pthread_t));

    for (thread = 0; thread &lt; thread_count; thread++)
        pthread_create(&amp;thread_handles[thread], NULL, hello, (void*) thread);

    printf(&quot;Hello from the main thread\n&quot;);
</code></pre>

<h4 id="destruicao">Destruição</h4>
<pre><code class="c">    for (thread = 0; thread &lt; thread_count; thread++)
        pthread_join(thread_handles[thread], NULL);

    free(thread_handles);
</code></pre>

<h4 id="execucao">Execução</h4>
<p>Compile com</p>
<pre><code class="bash">gcc -pthread teste.c -o teste
````

e execute com 
```bash
./teste 5
</code></pre>

<p>Observe que a saída das threads é <em>ordenada</em>. Agora experimente</p>
<pre><code class="bash">./teste 200
</code></pre>

<p>Isto acontece porquê a execução das threads independe da ordem de criação. De fato, usando PThreads, temos pouco controle sobre os threads que criamos. Mas isto não quer dizer que estamos "órfãos" de API.</p>
<ul>
<li><code>pthread_create</code> - cria novo thread</li>
<li>passagem de parâmetros</li>
<li>opções</li>
<li><code>pthread_join</code> - espera thread terminar</li>
<li>recebe resultado da thread</li>
<li><code>pthread_tryjoin</code> - espera thread terminar</li>
<li>
<p><code>pthread_exit</code> - termina a thread e retorna resultado </p>
<blockquote>
<p>An implicit call to \lstinline|pthread_exit()| is made when a thread other than the thread in which \lstinline|main()| was first invoked returns from the start routine that was used to create it. The function's return value serves as the thread's exit status. (manual do \lstinline|pthread_exit|)}</p>
</blockquote>
</li>
<li>
<p>pthread_attr_setaffinity_np* - ajusta afinidade dos threads.</p>
</li>
</ul>
<h4 id="threads-java">Threads Java</h4>
<p>Neste tutorial, baseado neste <a href="https://docs.oracle.com/javase/tutorial/essential/concurrency/">outro</a>, exploraremos formas de se obter concorrência em Java. Isto é, exploraremos como iniciar múltiplas linhas de execução de instruções, que podem ou não, ser executadas em paralelo.</p>
<p>Em Java, há essencialmente duas formas de se conseguir concorrência. A primeira é via instâncias explícitas da classe <code>Thread</code>, e a segunda é via abstrações de mais alto nível, os <code>Executors</code>.</p>
<hr />
<ul>
<li>Thread</li>
<li>Executor</li>
</ul>
<hr />
<p>Além de formas de definir as linhas de execução, Java provê diversas estruturas para comunicação e coordenação destas linhas, desde de a versão 5 da linguagem, no pacote <code>java.util.concurrent</code>.</p>
<h3 id="threads"><em>Threads</em></h3>
<p>Há duas formas básicas de se usar a classe <code>Thread</code>: extensão ou delegação de um objeto implementando <code>Runnable</code>.</p>
<hr />
<h5 id="estender-thread">Estender Thread</h5>
<pre><code class="Java">public class HelloThread extends Thread {
    public void run() {
        System.out.println(&quot;Hello from a thread!&quot;);
    }

    public static void main(String args[]) {
        Thread t = new HelloThread();
        t.start();
    }
}
</code></pre>

<hr />
<hr />
<h5 id="implementar-runnable">Implementar Runnable</h5>
<pre><code class="Java">public class HelloRunnable implements Runnable {
    public void run() {
        System.out.println(&quot;Hello from a thread!&quot;);
    }

    public static void main(String args[]) {
        Thread t = new Thread(new HelloRunnable());
        t.start();
    }
}
</code></pre>

<hr />
<p>Observe que nos dois exemplos, um método <code>run()</code> é implementado com o código a ser executado pelo <em>thread</em>. Em nenhum dos exemplos, contudo, o método é invocado diretamente. 
Em vez disto, o método <code>start()</code>, sim, é invocado. Isto ocorre pq antes de executar as instruções definidas pelo pelo programador no método <code>run()</code>,
a máquina virtual precisa executar alguma "mágica" por baixo dos panos como, por exemplo, solicitar ao sistema operacional a criação de um <em>thread</em> do SO, que servirá de hospedeiro para o <em>thread</em> Java. 
Isto acontece dentro do <code>start()</code>, que em algum ponto de sua execução levará a invocação do método <code>run()</code>.</p>
<p>A classe <code>Thread</code> também provê uma série de métodos que permitem gerenciar a vida do <em>thread</em> criado. 
Por exemplo, o método de classe (<code>static</code>) <code>Thread.sleep()</code> permite bloquear um <em>thread</em>  por um determinado período.</p>
<hr />
<h5 id="threadsleep">Thread.sleep()</h5>
<pre><code class="Java">public class HelloRunnable implements Runnable {
    public void run() {
        for (int i = 0; i &lt; 10; i ++)
        {
            System.out.println(&quot;Hello at instant &quot; + i);
            try {
                Thread.sleep(1000);
            } catch (InterruptedException ie) {
                System.out.println(&quot;awoken&quot;);
            }
        }
    }

    public static void main(String args[]) {
        Thread t = new Thread(new HelloRunnable());
        t.start();
    }
}
</code></pre>

<hr />
<p>Observe que a chamada a <code>sleep()</code> está dentro de um bloco <code>try/catch</code>. Isto é necessário pois é permitido à JVM acordar o <em>thread</em> em qualquer instante, antes ou após o tempo especificado. Assim, embora normalmente o tempo "dormido" seja próximo ao especificado, se há requisitos de precisão, é necessário que o <em>thread</em>, ao acordar, verifique se já dormiu o suficiente.</p>
<hr />
<h5 id="interruptedexception">InterruptedException</h5>
<pre><code class="Java">public class HelloRunnable implements Runnable {
    public void run() {
        for (int i = 0; i &lt; 10; i ++)
        {
            System.out.println(&quot;Hello at instant &quot; + i);
            long before = System.currentTimeMillis();
            long timeout = 1000;
            while(before + timeout &gt; System.currentTimeMillis())
            {
                try {
                    Thread.sleep(Math.max(0,System.currentTimeMillis() - (before + timeout)));
                } catch (InterruptedException ie) {
                    System.out.println(&quot;awoken&quot;);
                }
            }
        }
    }

    public static void main(String args[]) {
        Thread t = new Thread(new HelloRunnable());
        t.start();
    }
}
</code></pre>

<hr />
<p>Quando um <em>thread</em> está sendo executado, outros podem ter que esperar até que complete. Por exemplo, no caso de um navegador
Web, o <em>thread</em> que faz a renderização da página não pode começar a trabalhar enquanto o <em>thread</em>  que solicitou o HTML
do servidor não receber sua resposta. Um <em>thread</em> indica a intenção de esperar por outro usando o método <code>join()</code>.</p>
<hr />
<h5 id="threadjoin">Thread.join()</h5>
<pre><code class="Java">public class HelloRunnable implements Runnable {
    public void run() {
        Random rand = new Random();
        for (int i = 0; i &lt; 10; i ++)
        {
            System.out.println(&quot;Hello at instant &quot; + i);
            long before = System.currentTimeMillis();
            long timeout = 901 + rand.nextInt(200);
            while(before + timeout &gt; System.currentTimeMillis())
            {
                try {
                    Thread.sleep(Math.max(0,System.currentTimeMillis() - (before + timeout)));
                } catch (InterruptedException ie) {
                    System.out.println(&quot;awoken&quot;);
                }
            }
        }
    }

    public static void main(String args[]) {
        Thread t = new Thread(new HelloRunnable());
        //t.setDaemon(true);
        t.start();
        try {
            t.join();
            //t.join(10000);
        } catch (InterruptedException ie) {
            System.out.println(&quot;Waiting was interrupted&quot;);
        }
        if (t.isAlive())
            System.out.println(&quot;Got tired of waiting&quot;);
        else
            System.out.println(&quot;Wait is over&quot;);
    }
}
</code></pre>

<hr />
<p>Invocar <code>t.join()</code> fará com que o <em>thread</em> principal espere indefinidamente até que <code>t</code> termine de executar.
Caso seja necessário limitar o tempo de espera, o tempo pode ser especificado como na linha comentada. 
Caso a espera termine por causa de um <em>timeout</em>, é possível testar o estado atual do thread com <code>Thread.isAlive()</code>.</p>
<p>Outro método interessante, <code>Thread.setDaemon()</code>, especifica que o <em>thread</em> pode ser terminado quando a <em>thread</em> principal terminar. Descomente a invocação e teste o efeito.</p>
<h5 id="exercicio_1">Exercício</h5>
<p>Vejamos um exemplo simples do uso de <em>threads</em>.</p>
<ul>
<li>Instancie um programa que gere 10 <em>threads</em>. </li>
<li>Todos os <em>threads</em> devem compartilhar <strong>uma mesma instância</strong> de <code>Counter</code></li>
<li>Cada <em>thread</em> deve executar um <em>loop</em> em que incrementa o valor do contador 20 vezes </li>
<li>a cada vez, imprime o resultado precedido do identificador do <em>thread</em> (use <code>Thread.getName()</code> ou <code>Thread.currentThread().getName()</code>)</li>
<li>A <em>thread</em>  principal deve esperar todas as outras terminarem antes de terminar (use <code>Thread.join()</code>).</li>
<li>Analise a saída do programa observando a ordem de execução dos <em>threads</em>.</li>
</ul>
<hr />
<h5 id="counterjava">Counter.java</h5>
<pre><code class="Java">class Counter {
    private int c = 0;

    public int increment() {
        return ++c;
    }

    public int decrement() {
        return --c;
    }

    public int value() {
        return c;
    }
}
</code></pre>

<p>É fácil observar que a saída do programa é aleatória nos identificadores e tende a ser incremental nos contadores, mas nem sempre isso é verdade. 
Como discutido anteriormente, frequentemente <em>threads</em> tem que coordenar suas ações para que não pisem uns nos outros, por exemplo decidindo quem deve ser o próximo a entrar em uma região crítica ou será o responsável por uma tarefa. 
Em Java, esta coordenação pode ser feita por diversas abstrações: <code>synchronized</code>, <code>Lock</code>, variáveis atômicas, ...</p>
<h4 id="synchronized"><code>synchronized</code></h4>
<p>Ao definir métodos como <code>synchronized</code>, garante-se que os mesmos nunca serão executados concorrentemente. 
Observe a classe a seguir, que modifica o contador do exercício anterior.</p>
<hr />
<h5 id="synchronized_1">synchronized</h5>
<pre><code class="Java">public class SynchronizedCounter {
    private int c = 0;

    public synchronized int increment() {
        return ++c;
    }

    public synchronized int decrement() {
        return --c;
    }

    public synchronized int value() {
        return c;
    }
}
</code></pre>

<hr />
<p>Caso dois <em>threads</em> invoquem os métodos <code>increment</code> e <code>decrement</code> ao mesmo tempo, por exemplo, a JVM fará com que um dos <em>threads</em> pare sua execução até que o outro tenha completado a invocação.
Isto não quer dizer que executar o exercício anterior com esta versão do contador não levará a saídas com incrementos completamente sequenciais, pois um <em>thread</em>  poderia parar de ser executado logo após incrementar o contador, depois de terminado o método <code>increment</code>, e só voltar a executar depois que outro tenha incrementado e impresso na tela o valor obtido. 
O que quer dizer é que, mesmo que saídas estranhas existam, cada operação foi executada integralmente antes da operação seguinte.</p>
<h5 id="exercicio_2">Exercício</h5>
<p>Modifique o código do exercício anterior para usar a versão <code>synchronized</code> do contador. Depois de executá-lo, adicione um <code>println("Dentro: " + c)</code> <strong>dentro</strong> do método de incremento para verificar que estas saídas acontecem ordenadamente.</p>
<h4 id="blocos-synchronized">Blocos <code>synchronized</code></h4>
<p><code>synchronized</code> funciona porquê limita a concorrência, e é problemático exatamente pela mesma razão. 
Por isso, é essencial que o <code>synchronized</code> seja o mais limitado possível em termos de escopo, o que nos leva ao uso de <code>synchronized</code> em blocos de código menores que métodos. Por exemplo:</p>
<hr />
<h5 id="blocos-synchronized_1">blocos <code>synchronized</code></h5>
<pre><code class="Java">public class Namer {
    String lastName = null;
    int nameCount = 0;

    public void addName(String name) {
       lastName = name;
        synchronized(this) {
           nameCount++;
        }
        nameList.add(name);
    }
}
</code></pre>

<p>Neste caso, blocos sincronizados <strong>no mesmo objeto</strong>, não são executados concorrentemente, mas outros blocos sim.</p>
<h5 id="exercicio_3">Exercício</h5>
<p>Neste exercício, use dois objetos para travar o acesso a dois contadores. Instancie um programa com dois <em>threads</em>  tal que:
* executem um loop 1000 vezes em que
* o primeiro <em>thread</em> primeiro invoca <code>inc1</code> e depois <code>inc2</code>
* o segundo <em>thread</em> primeiro invoca <code>inc2</code> e depois <code>inc1</code>
* ambos os threads imprimem o valor de <code>c1</code> e <code>c2</code></p>
<hr />
<h5 id="synchronized_2">synchronized</h5>
<pre><code class="Java">public class MsLunch {
    private long c1 = 0;
    private long c2 = 0;
    private Object lock1 = new Object();
    private Object lock2 = new Object();

    public void inc1() {
        synchronized(lock1) {
            c1++;
        }
    }

    public void inc2() {
        synchronized(lock2) {
            c2++;
        }
    }
}
</code></pre>

<h4 id="deadlock"><em>Deadlock</em></h4>
<p>O uso dos "locks" em ordens diferentes pode levar a um deadlock, pois o seguinte grafo de dependência poderá ser gerado:</p>
<hr />
<h5 id="deadlock_1">Deadlock</h5>
<pre><code class="plantuml">digraph Test {
T1 -&gt; lock1
lock1 -&gt; T2
T2 -&gt; lock2
lock2 -&gt; T1
}
</code></pre>

<hr />
<h4 id="sinalizacao">Sinalização</h4>
<p>Usados corretamente, o bloco <code>synchronized</code> é executado de forma atômica, isto é, indivisível.
Algumas operações muito simples são naturalmente atômicas, e não precisam ser "protegidas" pelo <code>synchronized</code>.
Por exemplo, leituras e escritas de tipos básicos como (<code>int</code>, <code>char</code>, <code>byte</code>, mas não <code>long</code> ou <code>double</code>), ou variáveis declaradas <code>volatile</code>.</p>
<p>Usando estas variáveis, é possível coordenar <em>threads</em>, por exemplo, assim:</p>
<hr />
<h5 id="espera-ocupada">Espera ocupada</h5>
<pre><code class="Java">boolean condicao = false;

...

public void espereCondicao() {
    while(!condicao) {}
    System.out.println(&quot;condicao alcancada.&quot;);
}

...

public void satisfacaCondicao() {
    condicao = true;
}
</code></pre>

<hr />
<p>Embora correto, esta abordagem não é eficiente, pois o primeiro método desperdiça computação. 
Felizmente, em Java, todos os objetos implementam os métodos <code>wait</code> e <code>notify/notifyAll</code>, que podem ser usados para sincronizar eficientemente <em>threds</em>.</p>
<hr />
<h5 id="waitnotify">Wait/Notify</h5>
<pre><code class="Java">public class Sync{
   Object synch = new Object();
   boolean condicao = false;
   public void espereCondicao() {
      while(!condicao) {
         try {
            synch.wait();
         } catch (InterruptedException e) {}
      }
      System.out.println(&quot;Condicao alcancada&quot;);
   }
...
   public void satisfacaCondicao() {
      condicao = true;
      synch.notifyAll();
   }
}
</code></pre>

<hr />
<h4 id="locks"><em>Locks</em></h4>
<p>Outras abstrações para coordenação de <em>threads</em> estão disponíveis no pacote <code>java.util.concurrent</code>. 
As mais simples delas são <code>java.util.concurrent.locks.Lock</code> e <code>java.util.concurrent.locks.ReentrantLock</code>. 
Veja um exemplo de uso, notando o idioma de uso dentro de block <code>try/catch</code>.</p>
<hr />
<h5 id="lock">Lock</h5>
<pre><code class="Java">Lock l = new ReentrantLock();
  l.lock();
  try {
     // access the resource protected by this lock
  } finally {
     l.unlock();
  }
</code></pre>

<hr />
<h3 id="executor">Executor</h3>
<p>Além de <em>threads</em>, Java disponibiliza <code>Executor</code> como abstração de mais alto nível para execução de tarefas concorrentes.</p>
<hr />
<h5 id="executor_1">Executor</h5>
<ul>
<li><code>Executor</code></li>
<li><code>ExecutorService</code></li>
<li><code>ScheduledExecutorService</code></li>
</ul>
<pre><code>Executor e = ...;
Runnable r = ...;
e.execute(r);
</code></pre>

<hr />
<p>Executors normalmente implementam <em>thread pools</em>, que podem ser de diferentes tipos. 
O mais simples é o de tamanho fixo em que há um número inicial de <em>threads</em> criados e que, no caso de algum ser terminado, por exemplo por causa de uma exceção não tratada, cria substitutos para manter o número constante.</p>
<hr />
<h5 id="threadpool">ThreadPool</h5>
<p><code>Executor e = java.util.concurrent.Executors.newFixedThreadPool();</code></p>
<ul>
<li><code>newCachedThreadPool()</code> - <em>expandable thread pool</em></li>
<li><code>newSingleThreadExecutor()</code> - <em>single task at a time</em></li>
<li>e outras versões</li>
<li><code>ForkJoinPool</code></li>
</ul>
<hr />
<hr />
<h5 id="forkjoin">Fork/Join</h5>
<pre><code>if (my portion of the work is small enough)
  do the work directly
else
  split my work into two pieces
  invoke the two pieces and wait for the results
</code></pre>

<hr />
<h3 id="estrutura-para-coordenacao-de-threads">Estrutura para Coordenação de <em>Threads</em></h3>
<p>Finalmente, Java também disponibiliza estruturas de dados que podem ser acessadas concorrentemente por múltiplos <em>threads</em> 
sem risco de corrupção. </p>
<hr />
<h5 id="alguns-tipos-interessantes">Alguns tipos interessantes</h5>
<ul>
<li><code>BlockingQueue</code> - bloquei <em>threads</em>  se não houver elementos na filq.</li>
<li><code>ConcurrentMap/ConcurrentHashMap</code> - operações atômicas;</li>
<li><code>if (!m.containsKey(k)) m.put(k,v);</code></li>
<li><code>vOld = m.putIfAbsent(k,v);</code></li>
</ul>
<hr />
<hr />
<h5 id="tipos-atomicos">Tipos Atômicos</h5>
<pre><code class="java">import java.util.concurrent.atomic.AtomicInteger;

class AtomicCounter {
    private AtomicInteger c = new AtomicInteger(0);

    public void increment() {
        c.incrementAndGet();
    }

    public void decrement() {
        c.decrementAndGet();
    }

    public int value() {
        return c.get();
    }
}
</code></pre>

<hr />
<hr />
<h5 id="threadlocal">ThreadLocal</h5>
<pre><code class="java">private static ThreadLocal&lt;Integer&gt; myId = new ThreadLocal&lt;Integer&gt;() {
   public Integer initialValue() {
      return new Random().nexInt();
   } 
};

public static Integer getMyId() { 
    return myId.get();
}
</code></pre>

<hr />
<p>Para aprender mais, muito mais sobre concorrência em Java, ótimas referências são:</p>
<ul>
<li><a href="http://jcip.net/">Java Concurrency in Practice</a></li>
<li><a href="https://www.manning.com/books/the-well-grounded-java-developer">The Well-Grounded Java Developer</a></li>
<li><a href="http://docs.oracle.com/javase/tutorial/essential/concurrency/simple.html">Concorrência em Java</a></li>
<li><a href="http://winterbe.com/posts/2015/04/07/java8-concurrency-tutorial-thread-executor-examples/">Futures e Promises</a></li>
<li><a href="http://winterbe.com/posts/2015/04/30/java8-concurrency-tutorial-synchronized-locks-examples/">Locks</a></li>
<li><a href="http://winterbe.com/posts/2015/05/22/java8-concurrency-tutorial-atomic-concurrent-map-examples/">Tipos Atômicos</a></li>
</ul>
<hr />
<h4 id="threads-em-python">Threads em Python</h4>
<pre><code class="python">#!/usr/bin/python
import thread
import time

# Define a function for the thread
def print_time( threadName, delay):
   count = 0
   while count &lt; 5:
      time.sleep(delay)
      count += 1
      print &quot;%s: %s&quot; % ( threadName, time.ctime(time.time()) )

# Create two threads as follows
try:
   thread.start_new_thread( print_time, (&quot;Thread-1&quot;, 2, ) )
   thread.start_new_thread( print_time, (&quot;Thread-2&quot;, 4, ) )
except:
   print &quot;Error: unable to start thread&quot;

while True:
   pass
</code></pre>

<p>Ou</p>
<pre><code class="python">#!/usr/bin/python

import threading
import time

exitFlag = 0

class myThread (threading.Thread):
   def __init__(self, threadID, name, counter):
      threading.Thread.__init__(self)
      self.threadID = threadID
      self.name = name
      self.counter = counter
   def run(self):
      print &quot;Starting &quot; + self.name
      print_time(self.name, self.counter, 5)
      print &quot;Exiting &quot; + self.name

   def print_time(threadName, counter, delay):
      while counter:
         if exitFlag:
            threadName.exit()
         time.sleep(delay)
         print &quot;%s: %s&quot; % (threadName, time.ctime(time.time()))
         counter -= 1

# Create new threads
thread1 = myThread(1, &quot;Thread-1&quot;, 1)
thread2 = myThread(2, &quot;Thread-2&quot;, 2)

# Start new Threads
thread1.start()
thread2.start()

print &quot;Exiting Main Thread&quot;
</code></pre>

<p><a href="https://www.tutorialspoint.com/python/python_multithreading.htm">Threads em Python</a></p>
<h3 id="exercicio-anel-multithread">Exercício - Anel Multithread</h3>
<ul>
<li>Usando uma linguagem de alto-nível como C/C++/Java, escrever um programa que crie 30 threads e faça com que uma mensagem circule entre os mesmos. </li>
<li>A mensagem é uma string aleatória de pelo menos 80 caracteres. </li>
<li>A cada vez que um thread recebe a mensagem ele a imprime, modifica o primeiro caractere minúsculo para maiúsculo, caso exista, dorme por 1 segundo, e repassa a mensagem. </li>
<li>Quando todos os caracteres forem maiúsculos, o processo repassa a mensagem e então termina. </li>
<li>Antes de terminar, o processo deve imprimir a mensagem resultante.</li>
</ul>
              
            </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
      
        <a href="../intro/" class="btn btn-neutral" title="Introdução"><span class="icon icon-circle-arrow-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
      
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="versions">
    <span class="rst-current-version" data-toggle="rst-current-version">
      
      
        <span><a href="../intro/" style="color: #fcfcfc;">&laquo; Previous</a></span>
      
      
    </span>
</div>
    <script>var base_url = '..';</script>
    <script src="../js/theme.js" defer></script>
      <script src="../search/main.js" defer></script>
    <script defer>
        window.onload = function () {
            SphinxRtdTheme.Navigation.enable(true);
        };
    </script>

</body>
</html>
