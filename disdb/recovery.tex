\section{Checkpointing \& Recuperação}
\begin{frame}{Recuperação}
	Suponha que uma série de erros aconteceram no sistema, e que não é possível continuar o processamento como o sistema está. Neste cenário, é necessário ou avançar para um novo estado, livre de erros, ou retroceder a um estado correto anterior.
\end{frame}

\begin{frame}{Recuperação}
Voltar a um estado correto parece ser a solução mais fácil.

\pause Para isso, precisamos de \alert{Pontos de Recuperação}
\end{frame}

\begin{frame}{Snapshots}
Podem ser usados na:
\begin{itemize}
	\item Recuperação do sistema.
	\item Coleta de lixo (remover objetos não referenciados em nenhum outro processo).
	\item Deteção de deadlocks.
	\item Depuração (pausar o sistema).
\end{itemize}
\end{frame}

\begin{frame}{Pontos de Recuperação}
Ponto de Recuperação válidos são a união de backups locais que formam um \alert{Estado Global Consistente}.
\end{frame}

\begin{frame}{Estado Global Consistente}

\begin{block}{O quê?}
	Conjunto com um estado local de cada processo no sistema tal que toda mensagem recebida no estado local de um processo também precisa fazer parte do estado local do processo remetente.
\end{block}

\begin{block}{Linha de recuperação}
	O mais recente Estado Global Consistente
\end{block}

\includegraphics[width=.7\textwidth]{images/08-24}
\end{frame}


\begin{frame}{Estado Global Consistente}
\begin{block}{Comunicação Confiável}
Se o sistema provê comunicação confiável, então toda mensagem enviada no estado local de um processo também precisa fazer parte do estado local do destinatário.
\end{block}

\includegraphics[width=.7\textwidth]{images/08-24}
\end{frame}


\begin{frame}{Rollback em Cascata}
\begin{block}{Bad timing}
	Se estados locais são capturados na ``hora errada'', a linha de recuperação pode ser o estado inicial.
\end{block}

\includegraphics[width=.7\textwidth]{images/08-25}
\end{frame}

\begin{frame}{Armazenamento em Disco}
Segue a técnica já estudada.

\includegraphics[width=.7\textwidth]{images/08-23}
\end{frame}

\subsection{Checkpointing independente}

\begin{frame}{Checkpointing independente}
Cada processo faz o checkpoint local independentemente, incorrendo no risco de um \emph{rollback} em cascata.

\begin{itemize}
	\item Seja $C_i^m$ o $m$-ésimo checkpoint do processo $p_i$.
	\item Seja $I_i^m$ o intervalo entre $C_i^{m-1}$ e $C_i^m$.
	\item Quando o processo $p_i$ envia a mensagem no intervalo $I_i^m$, envia $(i,m)$ em piggyback
	\item Quando o processo $p_j$ recebe a mensagem no intervalo $I_j^n$, grava a dependência $I_i^m \rightarrow I_j^n$
	\item A dependência $I_i^m \rightarrow I_j^n$ é salva junto com o checkpoint $C_j^n$
\end{itemize}
\end{frame}


\begin{frame}{Checkpointing independente}
\begin{block}{Restrição}
Se o processo $p_j$ é revertido para o estado $C_j^n$, então o $p_i$ não pode reverter para nenhum estado anterior a $C_i^m$, ou não teria enviado as mensagens recebidas por $p_j$ 4 inclusas em $C_j^n$.
\end{block}

Ou

\begin{block}{Restrição}
Se o processo $p_i$ é revertido para o estado $C_i^{m-1}$, então o $p_j$ tem que ser revertido pelo menos até $C_j^{n-1}$, ou incluiria mensagens ainda não enviadas por $p_i$.
\end{block}

\pause Como implementar a recuperação?
\end{frame}

\begin{frame}{Caso patológico}
\begin{itemize}
	\item $p_i$ e $p_j$ no estado inicial ($C_i^0, C_j^0$)
	\item $p_i$ manda mensagens para $p_j$ ($C_i^1 \rightarrow C_j^1$)
	\item $C_j^1$
	\item $p_j$ manda mensagens para $p_i$ $C_j^2 \rightarrow C_i^1$
	\item $C_i^1$
	\item $p_i$ manda mensagens para $p_j$ $C_i^2 \rightarrow C_j^2$
	\item $C_j^2$
	\item $p_j$ manda mensagens para $p_i$ $C_j^3 \rightarrow C_i^2$
	\item $C_i^2$
	\item ...
\end{itemize}
\end{frame}



\subsection{Checkpointing coordenado}

\begin{frame}{Checkpointing coordenado}
Processos se coordenam por troca de mensagem para executar checkpointing ``simultaneamente''.

\pause Qual a vantagem sobre o não coordenado?

\end{frame}


\begin{frame}{Bloqueio em duas fases}
\begin{itemize}
	\item Um coordenador faz multicast da mensagem ``checkpoint-request''.
	\item Quando um participante recebe ``checkpoint-request''
	\begin{itemize}
		\item faz um checkpoint local,
		\item para de mandar mensagens da aplicação
		\item responde com ``checkpoint-taken''
	\end{itemize}
	\item Quando ``checkpoint-taken'' recebido de todos os participantes, multicast ``checkpoint-done''
	\item Quando receber ``checkpoint-done'', retoma computação normal
\end{itemize}

\begin{itemize}
	\item Por quê funciona? \pause Impede formação de dependências circulares.
	\item Todos os processos precisam participar? \pause Somente os que dependem da recuperação do coordenador.
\end{itemize}
\end{frame}

\begin{frame}{Bloqueio em duas fases}
Pontos negativos? \pause
\begin{itemize}
	\item Duas fases? Já vi isso antes... \pause Se o coordenador falha, outros processos ficam bloqueados? \pause Timeout!
	\item Como eleger outro coordenador? E se dois aparecerem juntos?\pause Pode ser resolvido com um protocolo de eleição como o do RAFT. \pause{} Não é garantido, mas aumenta as chances de sucesso.
\end{itemize}
\end{frame}

\begin{frame}{Chandy-Lamport}
	
	\begin{itemize}
		\item Não interfere na aplicação
		\item Cada processo grava snapshot independentemente
	\end{itemize}
\end{frame}


\begin{frame}{Chandy-Lamport}
	\begin{itemize}
		\item Observador (iniciador do snapshot)
		\begin{itemize}
			\item Salva o próprio estado
			\item Envia uma mensagem ``snapshot'' aos outros processos em cada canal de saída
			\item Grava as mensagens chegando em cada canal até que receba uma mensagem ``snapshot'' naquele canal.
		\end{itemize}
		\item Um processo $p$ que receba ``snapshot'' de um processo $q$
		\begin{itemize}
			\item grava estado local $S_p$
			\item grava estado do canal $C_{q,p} =\emptyset$
			\item Envia uma mensagem ``snapshot'' aos outros processos em cada canal de saída
			\item Grava as mensagens chegando em cada canal até que receba uma mensagem ``snapshot'' naquele canal (excluindo $C_{q,p}$)
		\end{itemize}
		\item Protocolo termina para o processo $p$ quando tiver recebido marcador ``snapshot'' em cada um de seus canais.
		\item O estado global consiste dos snapshots + estado em cada um dos canais.
		\pause \item Exige canais FIFO
	\end{itemize}
	
	\url{https://youtu.be/RQquDTYkHKY?t=383}
\end{frame}


\subsection{Message Logging}
\begin{frame}{Message Logging}
	Em vez de checkpoints frequentes, crie um log da comunicação e o re-execute a partir do último checkpoint.
	
	\begin{block}{Ideia}
		A computação é determinada pela troca de mensagens (eventos não determinísticos). 
		Ao se enviar a mesma mensagem a partir de um certo estado, a computação desencadeada é sempre a mesma.
	\end{block}
	
	\pause Realista este modelo? Há outros eventos não determinísticos no sistema?
\end{frame}

\begin{frame}{Message Logging}
	
	
	\includegraphics[width=\textwidth]{images/08-26}
\end{frame}

\begin{frame}{Notação}
	\begin{itemize}
		\item $Hdr(m)$
		\begin{itemize}
			\item Cabeçalho da mensagem $m$ contendo fonte, destino, número de sequência e número de entrega.
			\item O cabeçalho contém a informação necessária para reenviar e re-receber a mensagem na ordem certa (dados devem ser reproduzidos para aplicação).
			\item A mensagem $m$ é estável se $Hdr(m)$ estiver em memória estável.
		\end{itemize}
		\item $Dep(m)$ o conjunto de processos a quem $m$ ou mensagens que dependem de $m$ foram entregues.
		\item $Copy(m)$: o conjunto de processos que tem uma cópia de $Hdr(m)$ em memória volátil.
	\end{itemize}
\end{frame}

\begin{frame}{Órfãos}
	\begin{block}{Definição}
		Se $C$ é um conjunto de processos falhos, então $Q\not\in C$ é um órfão se existe uma mensagem $m$ tal que $Q \in Dep(m)$ e $Copy(m)\subseteq C$	
	\end{block}
	
	Se os processos em $C$ forem reiniciados, então a computação seguirá um caminho possivelmente distinto do que levou $Q$ a receber $m$ ou um mensagem causalmente dependente de $m$.

\end{frame}


\begin{frame}{Protocolo Pessimista}
	Para cada mensagem $m$ não estável, há no máximo um processo dependente em $m$ ($Dep(m) \leq 1$)
	
	\pause 
	Uma mensagem não estável, no protocolo pessimista, deve ser estabilizada antes do envio da próxima mensagem.
	
	\pause
	Toda mensagem é precedida por uma escrita em disco.
\end{frame}

\begin{frame}{Protocolo Otimista}
	Para cada mensagem $m$ não estável, então devemos garantir que se $Copy(m) \subseteq C$, então \emph{eventually} $Dep(m) \subseteq C$, onde $C$ é o conjunto de processos que falharam.
	
	\pause 
	Para garantir que $Dep(m) \subseteq C$, fazemos um rollback de cada órfão $Q$ até que $Q \not\in Dep(m)$
	
	\pause Isto é, forçamos $Q$ a ser recuperado mesmo que não tenha falhado.
\end{frame}

