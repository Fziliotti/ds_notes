<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  
  
  <link rel="shortcut icon" href="../../img/favicon.ico">
  <title>Tempo Lógico - Sistemas Distribuídos</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700" />

  <link rel="stylesheet" href="../../css/theme.css" />
  <link rel="stylesheet" href="../../css/theme_extra.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" />
  
  <script>
    // Current page data
    var mkdocs_page_name = "Tempo L\u00f3gico";
    var mkdocs_page_input_path = "tempo/2_logico.md";
    var mkdocs_page_url = null;
  </script>
  
  <script src="../../js/jquery-2.1.1.min.js" defer></script>
  <script src="../../js/modernizr-2.8.3.min.js" defer></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script> 
  
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
        <a href="../.." class="icon icon-home"> Sistemas Distribuídos</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../..">Prólogo</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../../intro/intro/">Introdução</a>
                    </li>
                </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../..">Sistemas Distribuídos</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../..">Docs</a> &raquo;</li>
    
      
    
    <li>Tempo Lógico</li>
    <li class="wy-breadcrumbs-aside">
      
    </li>
  </ul>
  
  <hr/>
</div>
          <div role="main">
            <div class="section">
              
                <h1 id="relogio-logicos">Relógio Lógicos</h1>
<p>Nas soluções anteriores, um nó precisa esperar por muito tempo antes de usar um recurso. 
E se ele aprendesse antes que os outros nós não farão requisições? 
Que não haverão sobreposições de requisições? 
E se houvesse um relógio que avançasse não com o tempo, mas com eventos interessantes do sistema?
Esta é a ideia dos <strong>relógios lógicos</strong>.</p>
<hr />
<h6 id="relogios-logicos">Relógios Lógicos</h6>
<ul>
<li>Envio e recepção (e possivelmente outros eventos) fazem o relógio ``ticar''.</li>
<li>Processos podem usar este relógio para concordar na <strong>ordem</strong> dos eventos, mesmo que não no <strong>instante</strong> do evento.</li>
<li>Não há <strong>fonte da verdade</strong> em termos de tempo.</li>
<li>Cada processo mantém seu próprio relógio que pode ser relacionado com relógios de outros processos.</li>
</ul>
<p>Para chegarmos aos relógios lógicos, precisamos primeiro entender a relação <em>Happened-Before</em>, proposta por Leslie Lamport em <a href="http://amturing.acm.org/p558-lamport.pdf">Time, Clocks and the Ordering of Events in a Distributed System. July 5, 1978</a>, que lhe rendeu um <a href="https://www.microsoft.com/en-us/research/blog/leslie-lamport-receives-turing-award/">Prêmio Turing em 2014</a>.
Neste artigo, se estabelece o vocabulário para falar sobre ordem de eventos em um sistema computacional, em especial um distribuído.</p>
<hr />
<h5 id="happened-before">Happened-Before</h5>
<ul>
<li>$a \rightarrow b$: evento $a$ aconteceu antes do evento $b$</li>
<li>Considerando um único processo (thread):</li>
<li>Se $a$ foi executado antes de $b$ no processo, então $a \rightarrow b$.</li>
<li>Considerando dois processos:</li>
<li>Se $a$ é o envio de uma mensagem e $b$ sua recepção, então $a \rightarrow b$.</li>
<li>Transitividade faz sentido:</li>
<li>Se $a \rightarrow b$ e $b \rightarrow c$, então $a \rightarrow c$</li>
</ul>
<hr />
<p>Esta relação captura a <strong>causalidade</strong> entre eventos. Isto é, se $a \rightarrow b$ então $a$ potencialmente causou $b$ ($a$ precede $b$ em uma ordem causal).
Note que se $a \rightarrow b$ é falso e $b \rightarrow a$ é falso, então $a$ e $b$ são <strong>concorrentes</strong>.</p>
<p>Se capturarmos a causalidade de eventos, podemos usar esta informação para ordenar o se processamento, de forma a fazer sentido.
Considere o seguinte exemplo:</p>
<p>TODO: Exemplo e emails com pergunta e respostas.</p>
<p>Para que computadores possam usar a causalidade, precisamos capturar a relação de acontecer antes em um sistema.
Lamport propôs uma tal forma, que denominou relógio lógico, mas que hoje é conhecido universalmente como Relógios de Lamport.
Estes relógios permitem associar um <em>timestamp</em> a eventos de forma a se garantir a seguinte propriedade:
* seja $e$ um evento
* seja $C(e)$ o valor do relógio lógico quando associado a $e$
* se $a \rightarrow b$ então $C(a) &lt; C(b)$</p>
<p>Mas como definir a função $C$?
Experimentemos a seguinte definição:
* Seja $c_p$ um contador em $p$ com valor inicialmente igual a 0.
* $C(e) = c++$ no momento em que $e$ ocorreu.
* Usamos como $ &lt; $ a relação normal de inteiros.
Assim, cada processo conta os eventos executados localmente.
Veja um exemplo desta definição em ação.</p>
<p>!(LC - Primeira tentativa)(imagess/lc_cont.png)</p>
<p>É verdade neste cenário que se $a \rightarrow b$ então $C(a) &lt; C(b)$?<br />
Observe com atenção os eventos $f$ e $k$. Para estes, a regra não é respeitada.
Para que seja, precisamos garantir que, na recepção de uma mensagem, os contadores sejam atualizados para que sejam maiores tanto que os relógios dos eventos locais quanto dos eventos que antecederam o envio da mensagem sendo recebida.
Com este ajuste, temos os Relógios de Lamport.</p>
<h2 id="lamport-clock">Lamport Clock</h2>
<ul>
<li>Seja $c_p$ um contador em $p$ com valor inicialmente igual a 0.</li>
<li>Se o evento $e$ é uma operação local, $C(e) = ++c$ no momento em que $e$ ocorreu.</li>
<li>Se o evento $e$ é o envio de uma mensagem, então $C(e)$ é enviado com a mensagem como seu timestamp.</li>
<li>Se o evento $e$ é a recepção de uma mensagem com timestamp $ts$, então $C(e) = max(c,ts)+1$.</li>
</ul>
<p>!(LC - Primeira tentativa)(imagess/lc_lamport.png)</p>
<p>Neste caso, temos que para quaisquer eventos $a,b$,  se $a \rightarrow b$ então $C(a) &lt; C(b)$.</p>
<p>TODO: Exemplo em que não é bom o suficiente.</p>
<p>Se $a \rightarrow b$ então $C(a) &lt; C(b)$. Contudo, a volta não é verdade, isto é, se $C(a) &lt; C(b)$ então $a \rightarrow b$.
Esta propriedade é interessante na ordenação de eventos, pois evita que eventos concorrentes sejam ordenados.
Entram os relógios vetoriais.</p>
<h2 id="relogio-vetorial">Relógio vetorial</h2>
<p>Sejam $n$ processos. No processo $p$
* Seja $c_p[i], 1 \leq i \leq n$ um contador, inicialmente igual a 0.
* Se o evento $e$ é uma operação local, $c_p[p]++$ e $C(e) = c_p$ no momento em que $e$ ocorreu.
* Se o evento $e$ é o envio de uma mensagem, então $C(e)$ é enviado com a mensagem como seu timestamp.
* Se o evento $e$ é a recepção de uma mensagem com timestamp $ts$ de $q$, então
  * $c_p[i] = max(c_p[i], ts[i]), i \neq p$
  * $c_p[p]++$
  * $C(e) = c_p$</p>
<p>!(Relógio Vetorial)[images/lc_vc.png]</p>
<p>Como dito, este relógio lógico tem a seguinte propriedade: se $a \rightarrow b \RightLeftArrow C(a) &lt; C(b)$.
Mas como é defido $ &lt; $ para vetores?
* $V = V' \iff V[i] = V'[i], 1 \leq i \leq n$
* $V \leq V' \iff V[i] \leq V'[i], 1 \leq i \leq n$</p>
<p>Sejam dois eventos $e$ e $e'$
* Se $e \rightarrow e' \iff V(e) &lt; V(e')$
* Se $V(e) \not\leq V(e')$ e $V(e') \not\leq V(e)$, são concorrentes.</p>
<p>Mas o que quer dizer $c_p[q] = k$?
Quer dizer que $p$ sabe que $q$ enviou $k$ mensagens.
E daí? O que pode ser feito com isso?<br />
Com estes mecanismos é possível implementar
* Multicast Totalmente Ordenado:
  * Multicast: mensagens são enviadas de 1 para n (comunicação em grupo)
  * Totalmente Ordenado: todos os processos entregam as mensagens na mesma ordem
* Multicast Causalmente Ordenado:
  * Causalmente Ordenado: uma mensagem só é entregue se todas as que causalmente a precedem já foram entregues.</p>
<p>Novamente você pergunta, e daí? Bem, com estas abstrações, podemos resolver problemas interessantes como o seguinte.
Considere um programa qualquer, que se comporte de forma determinística (isto é, dada uma mesma entrada, gera sempre uma mesma saída). Como todo programa, este é uma máquina de estados, com a peculiaridade de ser determinística.
Logo, se tivermos várias cópias deste programa, executando em locais distintos, mas garantirmos que cada cópia verá exatamente a mesma entrada de dados, então garantiremos que todas as cópias transitarão pelos mesmos estados e chegarão ao mesmo estado final.
Acontece que multicast totalmente ordenado pode garantir exatamente isso, que todas as cópias receberão a mesma entrada.</p>
<p>!(State Machine Replication)[images/06-11.png]</p>
<p>Esta técnica é conhecida como Replicação de Maáquinas de Estados (em inglês, (<em>State Machine Replication</em>)[https://en.wikipedia.org/wiki/State_machine_replication]), ou pelo menos o seu princípio.</p>
<p>Mas como podemos implementar estas primitivas de multicast usando relógios lógicos?
Considere o seguinte algoritmo.</p>
<hr />
<h6 id="multicast-totalmente-ordenado">Multicast totalmente ordenado</h6>
<ul>
<li>Fila com prioridade em cada processo.</li>
<li>Mensagens são enviadas a todos os processos e colocadas em uma fila local.</li>
<li>Mensagens recebidas são colocadas na fila local e ack é enviado de volta.</li>
<li>$p$ só entrega uma mensagem $m$ recebida de $q$, com timestamp $ts$ quando</li>
<li>$m$ está na cabeça da fila de $p$</li>
<li>Para cada processo $q$, há uma mensagem $m'$ de $q$, $ts'$, na fila de $p$ tal $ts &lt; ts'$</li>
<li>Canais confiáveis e FIFO.</li>
</ul>
<hr />
<hr />
<h6 id="multicast-causalmente-ordenado">Multicast causalmente ordenado</h6>
<ul>
<li>Mensagens são enviadas a todos os processos.</li>
<li>$p$ incrementa $c_p[p]$ somente no envio de mensagens.</li>
<li>$p$ só entrega uma mensagem recebida de $q$, com timestamp $ts$ quando</li>
<li>$ts[q] = c_p[q]+1$</li>
<li>$ts[k] \leq c_p[k], k \neq q$</li>
</ul>
<p>\includegraphics[width=.5\textwidth]{images/06-13}</p>
<p>Considere $c_{P_2}[0,2,2]$ e $ts=[1,3,0]$, de $P_0$. O que $P_2$ está esperando? Como age ao receber mensagem com $ts$?</p>
<hr />
<h2 id="exclusao-mutua-revisitada">Exclusao Mútua Revisitada</h2>
<p>Retorno à exclusão mútua</p>
<p>TODO: (Algoritmos de Excluão mútua baeados em LC)[http://www.cs.cmu.edu/~dga/15-440/F10/lectures/Distributed-Mutual-Exclusion-slides.pdf]</p>
<p>TODO: Algoritmo de Lamport, Ricart e agrawalla</p>
<p>TODO: Algoritmo de (Maekawa)[https://www.coursera.org/learn/cloud-computing-2/lecture/GMHYN/2-4-maekawas-algorithm-and-wrap-up]</p>
<h2 id="relogios-hibridos">Relógios Híbridos</h2>
<p>TODO: (Google TrueTime)[https://cloud.google.com/spanner/docs/true-time-external-consistency)</p>
<h2 id="hibrid-logical-clocks">Hibrid Logical Clocks</h2>
<p>!(Hibrid Logical Clock)[images/lc_hybrid]</p>
<p>Onde se lê 3,13, leia-se 3,10,3.</p>
<p>(Fonte)(http://muratbuffalo.blogspot.com.br/2014/07/hybrid-logical-clocks.html)</p>
<h2 id="interceptadores">Interceptadores</h2>
<p>!(Transparente para a aplicação)[images/06-10]</p>
              
            </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
      
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="versions">
    <span class="rst-current-version" data-toggle="rst-current-version">
      
      
      
    </span>
</div>
    <script>var base_url = '../..';</script>
    <script src="../../js/theme.js" defer></script>
      <script src="../../search/main.js" defer></script>
    <script defer>
        window.onload = function () {
            SphinxRtdTheme.Navigation.enable(true);
        };
    </script>

</body>
</html>
