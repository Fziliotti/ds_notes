


<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      <link rel="shortcut icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.1, mkdocs-material-5.1.1">
    
    
      
        <title>Tempo</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.a676eddb.min.css">
      
      
    
    
    
      
        <link href="https://fonts.gstatic.com" rel="preconnect" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700%7CRoboto+Mono&display=fallback">
        <style>body,input{font-family:"Roboto",-apple-system,BlinkMacSystemFont,Helvetica,Arial,sans-serif}code,kbd,pre{font-family:"Roboto Mono",SFMono-Regular,Consolas,Menlo,monospace}</style>
      
    
    
    
    
      
        
<link rel="preconnect dns-prefetch" href="https://www.google-analytics.com">
<script>window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","G-PJX835H7DP","lasarojc.github.org/dsnotes"),ga("set","anonymizeIp",!0),ga("send","pageview"),document.addEventListener("DOMContentLoaded",function(){document.forms.search&&document.forms.search.query.addEventListener("blur",function(){if(this.value){var e=document.location.pathname;ga("send","pageview",e+"?q="+this.value)}})}),document.addEventListener("DOMContentSwitch",function(){ga("send","pageview")})</script>
<script async src="https://www.google-analytics.com/analytics.js"></script>
      
    
    
  </head>
  
  
    <body dir="ltr">
  
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#neste-capitulo-discutiremos-o-que-sao-sistemas-distribuidos-por-que-os-desenvolvemos-e-damos-uma-visao-geral-de-como-isto-e-feito" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
      <header class="md-header" data-md-component="header">
  <nav class="md-header-nav md-grid" aria-label="Header">
    <a href=".." title="Notas em Sistemas Distribuídos" class="md-header-nav__button md-logo" aria-label="Notas em Sistemas Distribuídos">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12,8A3,3 0 0,0 15,5A3,3 0 0,0 12,2A3,3 0 0,0 9,5A3,3 0 0,0 12,8M12,11.54C9.64,9.35 6.5,8 3,8V19C6.5,19 9.64,20.35 12,22.54C14.36,20.35 17.5,19 21,19V8C17.5,8 14.36,9.35 12,11.54Z" /></svg>

    </a>
    <label class="md-header-nav__button md-icon" for="__drawer">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3,6H21V8H3V6M3,11H21V13H3V11M3,16H21V18H3V16Z" /></svg>
    </label>
    <div class="md-header-nav__title" data-md-component="header-title">
      
        <div class="md-header-nav__ellipsis">
          <span class="md-header-nav__topic md-ellipsis">
            Notas em Sistemas Distribuídos
          </span>
          <span class="md-header-nav__topic md-ellipsis">
            
              Tempo
            
          </span>
        </div>
      
    </div>
    
      <label class="md-header-nav__button md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5,3A6.5,6.5 0 0,1 16,9.5C16,11.11 15.41,12.59 14.44,13.73L14.71,14H15.5L20.5,19L19,20.5L14,15.5V14.71L13.73,14.44C12.59,15.41 11.11,16 9.5,16A6.5,6.5 0 0,1 3,9.5A6.5,6.5 0 0,1 9.5,3M9.5,5C7,5 5,7 5,9.5C5,12 7,14 9.5,14C12,14 14,12 14,9.5C14,7 12,5 9.5,5Z" /></svg>
      </label>
      
<div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" data-md-state="active">
      <label class="md-search__icon md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5,3A6.5,6.5 0 0,1 16,9.5C16,11.11 15.41,12.59 14.44,13.73L14.71,14H15.5L20.5,19L19,20.5L14,15.5V14.71L13.73,14.44C12.59,15.41 11.11,16 9.5,16A6.5,6.5 0 0,1 3,9.5A6.5,6.5 0 0,1 9.5,3M9.5,5C7,5 5,7 5,9.5C5,12 7,14 9.5,14C12,14 14,12 14,9.5C14,7 12,5 9.5,5Z" /></svg>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20,11V13H8L13.5,18.5L12.08,19.92L4.16,12L12.08,4.08L13.5,5.5L8,11H20Z" /></svg>
      </label>
      <button type="reset" class="md-search__icon md-icon" aria-label="Clear" data-md-component="search-reset" tabindex="-1">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19,6.41L17.59,5L12,10.59L6.41,5L5,6.41L10.59,12L5,17.59L6.41,19L12,13.41L17.59,19L19,17.59L13.41,12L19,6.41Z" /></svg>
      </button>
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Type to start searching
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
</header>
    
    <div class="md-container" data-md-component="container">
      
        
      
      
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              <div class="md-sidebar md-sidebar--primary" data-md-component="navigation">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    <nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="Notas em Sistemas Distribuídos" class="md-nav__button md-logo" aria-label="Notas em Sistemas Distribuídos">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12,8A3,3 0 0,0 15,5A3,3 0 0,0 12,2A3,3 0 0,0 9,5A3,3 0 0,0 12,8M12,11.54C9.64,9.35 6.5,8 3,8V19C6.5,19 9.64,20.35 12,22.54C14.36,20.35 17.5,19 21,19V8C17.5,8 14.36,9.35 12,11.54Z" /></svg>

    </a>
    Notas em Sistemas Distribuídos
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      


  <li class="md-nav__item">
    <a href=".." title="Prólogo" class="md-nav__link">
      Prólogo
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../intro/" title="Introdução" class="md-nav__link">
      Introdução
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../basics/" title="Fundamentos" class="md-nav__link">
      Fundamentos
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../comm/" title="Comunicação" class="md-nav__link">
      Comunicação
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../arch/" title="Arquiteturas" class="md-nav__link">
      Arquiteturas
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../coord/" title="Coordenação" class="md-nav__link">
      Coordenação
    </a>
  </li>

    
      
      
      

  


  <li class="md-nav__item md-nav__item--active">
    
    <input class="md-nav__toggle md-toggle" data-md-toggle="toc" type="checkbox" id="__toc">
    
      
    
    
    <a href="./" title="Tempo" class="md-nav__link md-nav__link--active">
      Tempo
    </a>
    
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../fault/" title="Tolerância a Falhas" class="md-nav__link">
      Tolerância a Falhas
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../disdb/index.md" title="Bancos de Dados" class="md-nav__link">
      Bancos de Dados
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../disfs/index.md" title="Sistemas de Arquivos" class="md-nav__link">
      Sistemas de Arquivos
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../tech/index.md" title="Tecnologias" class="md-nav__link">
      Tecnologias
    </a>
  </li>

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              <div class="md-sidebar md-sidebar--secondary" data-md-component="toc">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    
<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
    
  
  
</nav>
                  </div>
                </div>
              </div>
            
          
          <div class="md-content">
            <article class="md-content__inner md-typeset">
              
                
                
                  
                
                
                <h2 id="neste-capitulo-discutiremos-o-que-sao-sistemas-distribuidos-por-que-os-desenvolvemos-e-damos-uma-visao-geral-de-como-isto-e-feito">Neste capítulo discutiremos o quê são sistemas distribuídos, por quê os desenvolvemos, e damos uma visão geral de como isto é feito.</h2>
<p>layout: default
title: Tempo Físico
parent: Tempo
nav_order: 1</p>
<hr />
<h1 id="tempo">Tempo</h1>
<p>Se um mesmo arquivo no Dropbox é modificado em duas máquinas diferentes, enquanto as mesmas estão desconectadas, o quê acontece quando elas se reconectam?</p>
<hr />
<h5 id="problema">Problema</h5>
<p>Se dois arquivos com o mesmo nome são enviadas ao servidor, qual deve ser mantido?</p>
<hr />
<p>Uma possibilidade é aceitar o arquivo que chega primeiro e rejeitar o que chega depois. Mas imagine que seu serviço esteja interessado em registrar a anterioridade de ideias anotadas nos arquivos.  Neste caso, o sistema poderia dar anterioridade ao arquivo errado, isto é, o mais recentemente criado. </p>
<p>Outra abordagem, é manter janelas de aceite de arquivos, e dentro destas janelas, manter os arquivos com horário de <strong>criação</strong> menor. Neste caso, um trapaceiro poderia modificar seu relógico para fazer seu arquivo passar na frente.</p>
<p>Uma terceira abordagem é gerar uma terceira versão, com a "soma" das duas conflitantes. Para gerar esta terceira versão, faz mais sentido quebrar os arquivos em <em>operações de modificação</em>, e executar as operações de forma a chegar ao resultado final. O problema permanece, pois as operações agora devem ser ordenadas.</p>
<p>Em qualquer destas linhas de atuação, você tem em mãos um conflito para resolver, e autmatizar a resolução do mesmo é muito complicado. É por isso que o Dropbox deixa os dois arquivos para que o usuário analize e decida o que fazer, que servidores git permitem a submissão de apenas um conjunto de operações por vez para um mesmo repositório, e o Perforce trabalhe com <em>locks</em>  de arquivos.</p>
<p>De forma mais genérica, </p>
<hr />
<h5 id="problema_1">Problema</h5>
<p>Se duas operações originadas em clientes são enviadas ao servidor, qual deve ser executada primeiro?</p>
<hr />
<p>Alguns sistemas, contudo, tentam resolver automaticamente os conflitos. No caso do CassandraDB, usa-se</p>
<hr />
<h5 id="cassandradb">CassandraDB</h5>
<p><em>"last write wins"</em> ou "latest version wins"</p>
<hr />
<p>Onde <em>last</em> é definido pelo relógio do cliente. Acontece que a maior parte dos nossos sistemas não dá garantias de tempo na entrega de mensagens ou processamento de instruções. Assim, temos novo problema:</p>
<hr />
<h5 id="problema_2">Problema</h5>
<p>Como determinar qual foi enviada primeiro, em um sistema assíncrono?</p>
<hr />
<p>Assim, precisamos encontrar uma <strong>fonte de tempo confiável e distribuída</strong>.
O desafio começa com o entendimento de relógios físicos.</p>
<h2 id="relogios-fisicos">Relógios Físicos</h2>
<hr />
<h5 id="relogio-de-quartzo">Relógio de Quartzo</h5>
<ul>
<li>Diapazão de cristal cortado a laser.</li>
<li>Efeito Piezoelétrico invertido: corrente elétrica gera oscilção</li>
<li>Efeito Piezoelétrico: oscilação gera impulsos</li>
<li>Oscila a <span><span class="MathJax_Preview">32768 = 2^{15}</span><script type="math/tex">32768 = 2^{15}</script></span>Hz </li>
<li>Contador conta 1 segundo por <em>overflow</em></li>
<li>Trabalha de 5 a 35 Celcius</li>
<li>Tem erro de &frac12; segundo/dia</li>
<li>Frequência muda com idade</li>
<li>temperatura</li>
<li>corrente elétrica</li>
<li>imperfeições</li>
</ul>
<p><a href="https://www.explainthatstuff.com/quartzclockwatch.html">Fonte</a></p>
<hr />
<p>Embora adequado para humanos, o erro dos relógios de quartzo é inaceitável em algumas operações computacionais. Felizmente, estes relógios podem ser corrigidos usando outras constantes físicas. </p>
<hr />
<h5 id="relogio-atomico">Relógio Atômico</h5>
<ul>
<li>relógio de quartzo gera 9.192.631.770 impulsos por segundo</li>
<li>impulsos mantem cesium-133 excitado</li>
<li>se número de átomos excitados cai, relógio é corrigido.</li>
<li><em>drift</em> de 1 segundo em 6.000.000 anos.</li>
</ul>
<hr />
<p>Uma vez que agora temos um relógio com altíssima precisão, como podemos espalhar esta informação para nossos computadores pessoais? A resposta está no UTC, Tempo Universal Coordenado (da sigla em Francês).</p>
<hr />
<h5 id="tempo-coordenado-universal-utc-do-nome-em-frances">Tempo Coordenado Universal -- UTC (do nome em Francês)</h5>
<blockquote>
<p>Nearly all UTC days contain exactly 86,400 SI seconds with exactly 60 seconds in each minute. However, because the mean solar day is slightly longer than 86,400 SI seconds, occasionally the last minute of a UTC day is adjusted to have 61 seconds. The extra second is called a leap second. It accounts for the grand total of the extra length (about 2 milliseconds each) of all the mean solar days since the previous leap second. The last minute of a UTC day is permitted to contain 59 seconds to cover the remote possibility of the Earth rotating faster, but that has not yet been necessary.</p>
</blockquote>
<hr />
<p>Abrindo um parêntese, o UTC é usado como <strong>base</strong> para os relógios locais, mas fatores políticos também são importantes.</p>
<hr />
<h5 id="fuso-horarios">Fuso-horários</h5>
<p><img alt="Fuso-horários" src="images/TimeZones.png" /></p>
<p><a href="https://commons.wikimedia.org/w/index.php?curid=42165217">Fonte</a></p>
<hr />
<p>Mas como o UTC é definido? Com base no TAI, Tempo Atômico Internacional, calculado como a média dos valores de relógios atômicos espalhados pelo globo. O TAI mede perfeitamente a passagem do tempo, mas como a rotação da terra é irregular, medir perfeitamente não é o adequado. Assim, o UTC leva em consideração o fato do dia não ter exatamente 24 horas e, de fato, não ter duração constante. Por exemplo, após um grande terremoto o centro de massa da terra pode ser alterado e a rotação ter sua velocidade aumentada ou diminuída.</p>
<hr />
<h5 id="utc">UTC</h5>
<ul>
<li>TAI - Tempo Atômico Internacional -- média de +- 200 relógios atômicos.</li>
<li>UT0 - Tempo solar, em Greenwich; observações astronômicas</li>
<li>UT1 - UT0 + correções por movimento polar (terra se inclinou?)</li>
<li>UT2 - UT1 + variações sazonais na rotação (placas tectônicas se movimentaram)</li>
<li>UTC - Medido como TAI mas aproximado para UT0 para dar percepção de que "meio dia é meio dia"</li>
</ul>
<hr />
<p>Dado o UTC, temos então uma referência de tempo adequada para uso em sistemas computacionais. Nos resta ainda, propagar a referência do UTC para os sistemas. Vejamos como o tempo é mantido em um computador.</p>
<hr />
<h5 id="relogios-nos-computadores">Relógios nos Computadores</h5>
<ul>
<li>Cada computador mantém uma visão local do tempo.</li>
<li>Relógio de quartzo mede a passagem de tempo.</li>
<li>Bateria usada para períodos de desconexão.</li>
<li>Interrupções programadas: Linux &gt;2.6 usa 250Hz por padrão; máximo 1000Hz.</li>
<li>Interrupções incrementam contador:</li>
<li>1000Hz, 1 interrupção a cada 1ms</li>
<li>500Hz, 1 interrupção a cada 2ms</li>
<li>Contador usado como base para relógio em software <span><span class="MathJax_Preview">C</span><script type="math/tex">C</script></span>.</li>
</ul>
<hr />
<p>Este relógio em software, <span><span class="MathJax_Preview">C</span><script type="math/tex">C</script></span>, que usa um relógio de quartzo, impreciso, pode marcar a passagem do tempo com erro para mais ou para menos.
Embora o erro exato do relógio seja desconhecido, o mesmo pode ser limitado.</p>
<hr />
<h5 id="sincronizacao">Sincronização</h5>
<ul>
<li>C - clock</li>
<li>t - tempo, ou melhor aproximação, UTC </li>
<li><span><span class="MathJax_Preview">\rho</span><script type="math/tex">\rho</script></span> - Clock-drift/Drift rate</li>
</ul>
<p><img alt="Drift rate" src="images/tanembaum-06-05.png" /></p>
<p><span><span class="MathJax_Preview">1 - \rho \leq \frac{dC}{dt} \leq 1 + \rho</span><script type="math/tex">1 - \rho \leq \frac{dC}{dt} \leq 1 + \rho</script></span>.</p>
<hr />
<p>Logo, dado um mecanismo de sincronização com UTC ou outra fonte confiável, podemos limitar a dessincronização com UTC.</p>
<hr />
<h5 id="frequencia-de-sincronizacao">Frequencia de Sincronização</h5>
<p>Como garantir que dois relógios do sistema não diferirão em mais que <span><span class="MathJax_Preview">\delta</span><script type="math/tex">\delta</script></span> unidades de tempo?</p>
<p>Sincronize pelo menos a cada <span><span class="MathJax_Preview">\frac{\delta}{2\rho}</span><script type="math/tex">\frac{\delta}{2\rho}</script></span> segundos.</p>
<hr />
<p>Vejamos um exemplo:</p>
<ul>
<li><span><span class="MathJax_Preview">\rho = 0,1</span><script type="math/tex">\rho = 0,1</script></span></li>
<li><span><span class="MathJax_Preview">\delta</span><script type="math/tex">\delta</script></span> = 1s</li>
<li>Após 10s, um nó com estas características se dessincronizaria em, no máximo, 1s em relação ao UTC. </li>
<li>Como cada nó poderia estar errando em "direções"  diferentes, após 5s, um nó poderia se adiantar em 0,5s enquanto o outro se atrasa pela mesma quantidade de tempo, somando 1s de diferença. Logo, eles tem que se sincronizar a cada 5s, i.e, <span><span class="MathJax_Preview">\frac{\delta}{2\rho} = \frac{1s}{2 \times 0,1} = \frac{1s}{0,2} = 5s</span><script type="math/tex">\frac{\delta}{2\rho} = \frac{1s}{2 \times 0,1} = \frac{1s}{0,2} = 5s</script></span></li>
</ul>
<p>Mas não se pode apenas ajustar o relógio para corrigir atrasos e adiantamentos. É preciso tomar certos cuidados para se garantir o funcionamento correto do sistema.</p>
<hr />
<h5 id="cuidados">Cuidados</h5>
<ul>
<li>Nunca voltar no tempo</li>
<li>Correção gradual: acelere ou desacelere o relógio (em software)<ul>
<li>Diminua/Aumente frequência de interrupção para atrasar/adiantar relógio</li>
<li>Diminua/Aumente incremento com cada interrupção</li>
</ul>
</li>
<li>Ajustes periódicos para fazer curvas convergirem.</li>
<li>Correção após dormir será mais drástica</li>
</ul>
<hr />
<p>Até agora definimos que relógios podem ser sincronizados com UTC, pois é uma boa aproximação do tempo percebido por nossos sentidos, e a frequência com que a sincronização deve acontecer. Contudo, falta ainda definir o protocolo pelo qual a sincronização é feita e exatamente com quem, uma vez que simpleste UTC é muito genérico. Comecemos com "quem". Em um extremo, sincronize com relógios atômicos em satélites GPS</p>
<hr />
<h5 id="sincronizar-com-quem-gps">Sincronizar com quem? GPS</h5>
<ul>
<li>Coloque um receptor GPS em cada nó.</li>
<li>Tenha erro de 0,1ns a 1ms do UTC.</li>
</ul>
<hr />
<p>Receptores GPS, com seus relógios sincronizados com os dos satélites, que difundem regularmente sua posição e o instante em que a difusão é feita, determinam sua posição relativa aos satélites, em uma técnica conhecida como trilateração.</p>
<p>Baseado na informação de um satélite, o receptor determina sua distância ao mesmo e, portanto, determina que está em uma esfera no entorno do satélite.
Combinando a informação de 2 satélites, a posição do receptor é limitada a uma circunferência, isto é, a interseção de duas esferas. 
Com um terceiro satélite, a posição é reduzida a dois pontos, a interseção de uma esfera e uma circunferência, sendo um no espaço e que pode ser facilmente descartado. </p>
<hr />
<h5 id="trilateracao">Trilateração</h5>
<p><img alt="Funcionamento de GPS" src="https://gisgeography.com/wp-content/uploads/2016/11/GPS-Trilateration-Feature-678x322.png" /></p>
<hr />
<p>Como dito, a trilateração consiste em determinar a distância do receptor em termos dos eixos <span><span class="MathJax_Preview">x</span><script type="math/tex">x</script></span>, <span><span class="MathJax_Preview">y</span><script type="math/tex">y</script></span> e <span><span class="MathJax_Preview">z</span><script type="math/tex">z</script></span> em relação a cada um dos satélites. Contudo, para que funcione, relógios precisam estar sincronizados, o que é exatamente o problema que estamos tentando resolver. 
Para contornar esta restrição, usa-se um quarto satélite, para determinar a distância no "eixo temporal".</p>
<p>Apesar da queda dos preços dos receptores, colocar um GPS em cada dispositivo pode ser custoso demais. Em vez disso, podemos usar um recurso amplamente disponível, redes de computadores, e sincronizar com outra máquina, que fez o investimento necessário para manter o erro baixo.</p>
<hr />
<h5 id="sincronizar-com-quem-outra-maquina">Sincronizar com quem? Outra máquina</h5>
<ul>
<li>Pergunte que horas são.</li>
<li>Use a resposta para ajudar o relógio local.</li>
<li>Considere o erro introduzido pela latência variável da rede.</li>
</ul>
<hr />
<h4 id="algoritmo-de-cristian">Algoritmo de Cristian</h4>
<p>Assumindo que o relógio da máquina se sincronizando, <span><span class="MathJax_Preview">M_1</span><script type="math/tex">M_1</script></span>, é bom o suficiente para medir a passagem de tempo em períodos curtos, mesmo que tenha uma <em>drift</em> rate considerávem em períodos mais longos, execute o seguinte protocolo para se sincronizar com <span><span class="MathJax_Preview">M_2</span><script type="math/tex">M_2</script></span>.</p>
<hr />
<h5 id="algoritmo-de-cristian_1">Algoritmo de Cristian</h5>
<ul>
<li><span><span class="MathJax_Preview">M_1</span><script type="math/tex">M_1</script></span> rergunta "que horas são?" - <span><span class="MathJax_Preview">t_0</span><script type="math/tex">t_0</script></span></li>
<li><span><span class="MathJax_Preview">M_2</span><script type="math/tex">M_2</script></span> recebe pergunta - <span><span class="MathJax_Preview">t_1</span><script type="math/tex">t_1</script></span></li>
<li><span><span class="MathJax_Preview">M_2</span><script type="math/tex">M_2</script></span> anota o valor do relógio - <span><span class="MathJax_Preview">t_s</span><script type="math/tex">t_s</script></span></li>
<li><span><span class="MathJax_Preview">M_2</span><script type="math/tex">M_2</script></span> envia resposta - <span><span class="MathJax_Preview">t_2</span><script type="math/tex">t_2</script></span></li>
<li>
<p><span><span class="MathJax_Preview">M_1</span><script type="math/tex">M_1</script></span> recebe resposta - <span><span class="MathJax_Preview">t_3</span><script type="math/tex">t_3</script></span></p>
</li>
<li>
<p>Assuma <span><span class="MathJax_Preview">t_1 = t_s = t_2</span><script type="math/tex">t_1 = t_s = t_2</script></span></p>
</li>
<li>
<p>Assuma <span><span class="MathJax_Preview">\frac{t_3-t_0}{2}</span><script type="math/tex">\frac{t_3-t_0}{2}</script></span> como o tempo de transmissão da resposta (média da ida e da volta)</p>
</li>
<li><span><span class="MathJax_Preview">M_1</span><script type="math/tex">M_1</script></span> ajusta relógio para <span><span class="MathJax_Preview">t_c = t_s + \frac{t_3-t_0}{2}</span><script type="math/tex">t_c = t_s + \frac{t_3-t_0}{2}</script></span></li>
</ul>
<hr />
<p>Mas e a aproximação <span><span class="MathJax_Preview">\frac{t_3-t_0}{2}</span><script type="math/tex">\frac{t_3-t_0}{2}</script></span>, é boa?
Podemos estimar o erro que ela introduz na sincronização, caso as mensagens tenham tempos de ida e volta assimétricos. Apesar das diferenças no tempo de ida e volta, existe um tempo mínimo para o tráfego em cada um dos sentidos, <span><span class="MathJax_Preview">T_{min}</span><script type="math/tex">T_{min}</script></span>.</p>
<hr />
<h5 id="erro-maximo">Erro máximo?</h5>
<p>Tempo mínimo de transmissão: <span><span class="MathJax_Preview">T_{min}</span><script type="math/tex">T_{min}</script></span></p>
<p><img alt="Erro do algoritmo de Christian" src="images/cristianerror.png" /></p>
<p><a href="https://www.cs.rutgers.edu/~pxk/417/notes/content/05-clock-synchronization-slides.pdf">Fonte</a></p>
<hr />
<p>Há dois casos extremos de erro na estimativa.
No primeiro caso, dado um tempo de ida + volta igual a <span><span class="MathJax_Preview">T_1 - T_0</span><script type="math/tex">T_1 - T_0</script></span>, na figura, a mensagem de ida trafega no tempo mínimo e a volta lentamente. Neste caso, a estimativa <span><span class="MathJax_Preview">\frac{t_3-t_0}{2}</span><script type="math/tex">\frac{t_3-t_0}{2}</script></span> é menor que o tempo de volta real.
No segundo caso, a mensagem de ida trafega lentamente e a de volta no tempo mínimo, levando <span><span class="MathJax_Preview">\frac{t_3-t_0}{2}</span><script type="math/tex">\frac{t_3-t_0}{2}</script></span> a ser maior que tempo de transmissão real da mensagem.
O erro, contudo, está limitado à faixa amarela no desenho, que tem duração <span><span class="MathJax_Preview">T_1 - T_0 - 2T_{min}</span><script type="math/tex">T_1 - T_0 - 2T_{min}</script></span>. O erro então varia de mais ou menos metade deste valor. </p>
<h4 id="algoritmo-de-berkeley">Algoritmo de Berkeley</h4>
<p>Enquanto o algoritmo de Cristian permite sincronizar um nó com uma fonte, outro algoritmo, de Berkeley, permite sincronizar múltiplos nós uns com os outros. Este algoritmo funciona assim:</p>
<hr />
<h5 id="algoritmo-de-berkeley_1">Algoritmo de Berkeley</h5>
<ul>
<li>
<p>Premissas</p>
<ul>
<li>Não há fonte da verdade</li>
<li>Sintonização em vez de sincronização (sincronização interna x externa)</li>
<li>Todos convergem para média</li>
<li>Todos executam ``time d\ae mon''</li>
<li>Mestre e escravos</li>
</ul>
</li>
<li>
<p>Algoritmo</p>
<ul>
<li>Mestre requisita relógio de cada escravo</li>
<li>Relógios ajustados com algoritmo de Cristian</li>
<li>Computa média</li>
<li>Envia ajuste para cada escravo</li>
</ul>
<p><img alt="Exemplo do algoritmo de Berkeley" src="http://www.myassignmenthelp.net/images/berkeley-algorithm-example-3.jpg" /></p>
</li>
<li>
<p>Importante</p>
<ul>
<li>Ignora \emph{outliers}</li>
<li>Mestre pode ser substituído facilmente</li>
</ul>
</li>
</ul>
<hr />
<p>Embora interessantes, estes algoritmos não são normalmente usados, pelo menos não em sua forma "pura", em sistemas computacionais. Em vez deles, usamos o Network Time Protocol (NTP).</p>
<hr />
<h5 id="network-time-protocol">Network Time Protocol</h5>
<ul>
<li>1991/1992: RFC 1305</li>
<li>2010: RFC 5905-5908 -- IPv6, 10s ms de acurácia</li>
<li>Uso na Internet</li>
<li>Sincronização com UTC</li>
<li>Estatística permite minimizar erros</li>
<li>Tolerante a falhas: caminhos redundantes; servidores redundantes</li>
<li>Escalável: modelo hierárquico</li>
<li>Seguro: usa autenticação</li>
</ul>
<hr />
<p>Os diversos componentes do NTP são organizados em camadas, ou estrata, de forma que a informação do tempo flui da camada 0 (stratum 0) até a camada 15 (stratum 15).
Os componentes não estão presos a camadas, que podem ser alteradas a medida que falhas acontecem e são dedicadas, e novos caminhos são encontrados usando-se um algoritmo de árvore geradora mínima.</p>
<hr />
<h5 id="network-time-protocol_1">Network Time Protocol</h5>
<p><img alt="Network Time Protocol" src="images/ntp.png" /></p>
<p><a href="https://commons.wikimedia.org/w/index.php?curid=2815097">Fonte: Benjamin D. Esham, (bdesham) - Based upon Ntp.png by Kim Meyrick</a></p>
<ul>
<li>Stratum 0: relógios atômicos/receptores GPS</li>
<li>Stratum 1: ms to stratum 0</li>
<li>Stratum 2: contata múltiplos stratum 1 e pares</li>
<li>Strata 3...15</li>
<li>Stratum 16: dessincronizado</li>
<li>Bellman-Ford: árvore geradora mínima para stratum 1</li>
</ul>
<hr />
<p>O sítio do Comitê Gestor da Internet, CGI, tem uma entrada muito boa sobre o NTP, <a href="https://ntp.br/ntp.php">NTP.br</a>.
De forma resumida, o NTP trabalha em diferentes modos, que permitem aos nós receberem informações de fontes de tempo das camadas superiores ou de pares, filtrar estas informações para escolher as mais confiáveis, e ajustar o relógio local de acordo com a filtragem.</p>
<hr />
<h5 id="modos-de-trabalho-do-ntp">Modos de trabalho do NTP</h5>
<ul>
<li>Modo multicast: propaga tempo em rede local</li>
<li>RPC: algoritmo de Cristian</li>
<li>Simétrico: parecido com Berkeley</li>
</ul>
<hr />
<p>Na prática, boa parte dos dispositivos usa uma versão simplificada do NTP, adequada aos nós nas folhas da hierarquia. O SNTP é essencialmente o algoritmo de Cristian.</p>
<hr />
<h5 id="simple-ntp">Simple NTP</h5>
<ul>
<li>Versão simplificada do NTP</li>
<li>Recomendado para folhas da árvore</li>
<li><span><span class="MathJax_Preview">\delta = (t_4-t_1)-(t_2-t_3)</span><script type="math/tex">\delta = (t_4-t_1)-(t_2-t_3)</script></span></li>
<li><span><span class="MathJax_Preview">t = \frac{(t_2-t_1)+(t3-t_4)}{2}</span><script type="math/tex">t = \frac{(t_2-t_1)+(t3-t_4)}{2}</script></span></li>
<li><span><span class="MathJax_Preview">t_c = t_4+t</span><script type="math/tex">t_c = t_4+t</script></span></li>
</ul>
<hr />
<p>Veja um exemplo do ajuste de um relógio usando SNTP.</p>
<hr />
<h5 id="exemplo-do-sntp">Exemplo do SNTP</h5>
<ul>
<li><span><span class="MathJax_Preview">t_1 = 1100, t_2 = 800, t_3=850, t_4=1200</span><script type="math/tex">t_1 = 1100, t_2 = 800, t_3=850, t_4=1200</script></span></li>
<li><span><span class="MathJax_Preview">t = ((800-1100)+(850-1200))/2 = (-300 -350)/ = -325</span><script type="math/tex">t = ((800-1100)+(850-1200))/2 = (-300 -350)/ = -325</script></span></li>
<li><span><span class="MathJax_Preview">t_c = 1200-325 = 875</span><script type="math/tex">t_c = 1200-325 = 875</script></span></li>
</ul>
<hr />
<p>Mais recentemente foi proposta um novo protocolo de sincronização de relógios com melhor qualidade de servço,  Precision Time Protocol, PTP.</p>
<hr />
<h5 id="ptp-precision-time-protocol">PTP - Precision Time Protocol</h5>
<ul>
<li>IEEE 1588</li>
<li>LAN</li>
<li>
<p>sub <span><span class="MathJax_Preview">\mu s</span><script type="math/tex">\mu s</script></span> (versus ordem de <span><span class="MathJax_Preview">ms</span><script type="math/tex">ms</script></span> no NTP)</p>
</li>
<li>
<p>Escolha mestre</p>
<ul>
<li>Administrador</li>
<li>Classe do relógio</li>
<li>Acurácia do relógio</li>
<li>Variância do relógio</li>
<li>Identificador</li>
</ul>
</li>
<li>Como algoritmo de Cristian, mas quem ajusta não é quem inicia.</li>
</ul>
<hr />
<p>Assumindo que tenhamos sincronizado os relógios de um sistema computacional, o que podemos fazer agora? Há uma série de problemas interessantes que podem ser resolvidos.</p>
<hr />
<h5 id="usos-de-relogios-sincronizados">Usos de relógios sincronizados</h5>
<ul>
<li>autenticação</li>
<li>terminação de transações </li>
<li>alocação de ``leases''.</li>
<li>outros exemplos, <a href="http://rdcu.be/s4iy">Liskov, B. Distrib Comput (1993) 6: 211. doi:10.1007/BF02242709</a></li>
</ul>
<hr />
<p>Um exemplo interessante é a ordenação de eventos em um banco de dados.
Para entender este problema, considere o seguinte cenário.</p>
<hr />
<h5 id="sistema-bancario">Sistema Bancário</h5>
<p><img alt="Sistema Bancário Replicado" src="images/tanenbaum-06-11.png" /></p>
<p>Se os comandos chegam primeiro para a replica mais próxima e são executados na ordem em que chegam, temos inconsistências entre as réplicas (p.e., assuma que update 1 é "atualize para 10" e 2 é "atualize para 20")</p>
<hr />
<p>Assim, precisamos ordenar os comandos!
Nos foquemos em apenas uma réplica.
Assuma que relógios estão <strong>perfeitamente</strong> sincronizados, que o tempo de propagação máximo de uma mensagem é <span><span class="MathJax_Preview">\tau</span><script type="math/tex">\tau</script></span>, e que toda mensagem/update carrega o <em>timestamp</em> de quando foi enviada consigo.
Considere o seguinte proposta:
Réplicas processam mensagens na ordem que foram enviadas, o que pode ser identificado pelos seus timestamps.
Em outras palavras, ao receber uma mensagem com timestamp <span><span class="MathJax_Preview">t</span><script type="math/tex">t</script></span>, uma réplica espera até ter certeza de que </p>
<hr />
<h5 id="ordenacao-de-requisicoes">Ordenação de Requisições</h5>
<ul>
<li>Relógios <strong>perfeitamente</strong> sincronizados</li>
<li><span><span class="MathJax_Preview">\tau</span><script type="math/tex">\tau</script></span>.</li>
<li>Cliente 1 envia mensagem Update1 no instante <span><span class="MathJax_Preview">t</span><script type="math/tex">t</script></span>.</li>
<li>
<p>Ao receber Update1 com timestamp <span><span class="MathJax_Preview">t</span><script type="math/tex">t</script></span>, a réplica deve esperar para executar o update?</p>
<p><img alt="Ordenação" src="images/ordenacao1.png" /></p>
<p>O último instante em que qualquer mensagem com timestamp <span><span class="MathJax_Preview">t' &lt; t</span><script type="math/tex">t' < t</script></span> pode ser recebido pela réplica é <span><span class="MathJax_Preview">t+\tau</span><script type="math/tex">t+\tau</script></span>, pois qualquer mensagem recebida em <span><span class="MathJax_Preview">t''&gt; t+\tau'</span><script type="math/tex">t''> t+\tau'</script></span>, precisa ter sido enviada após <span><span class="MathJax_Preview">t</span><script type="math/tex">t</script></span>, e portanto terá timestamp <span><span class="MathJax_Preview">&gt; t</span><script type="math/tex">> t</script></span>. </p>
</li>
</ul>
<hr />
<p>Implementar este protocolo é muito simples:</p>
<ul>
<li>Toda mensagem recebida é colocada em uma fila ordenada por <em>timestamp</em>.</li>
<li>Quando o relógio marcar um tempo maior que <span><span class="MathJax_Preview">t + \tau</span><script type="math/tex">t + \tau</script></span>, onde <span><span class="MathJax_Preview">t</span><script type="math/tex">t</script></span> é o timestamp da mensagem na cabeça da fila, execute tal mensagem e a retire da fila.</li>
</ul>
<p>Entretanto, este protocolo não leva em consideração a dessincronização inerente dos relógios em um sistema distribuído. Como fazê-lo, supondo uma divergência máxima de <span><span class="MathJax_Preview">\Delta</span><script type="math/tex">\Delta</script></span> entre quaisquer dois relógios, algo que pode ser arranjado, como visto antes, sincronizando-se os relógios a cada <span><span class="MathJax_Preview">\frac{\Delta}{2*\rho}</span><script type="math/tex">\frac{\Delta}{2*\rho}</script></span>.</p>
<p>Se <span><span class="MathJax_Preview">\Delta</span><script type="math/tex">\Delta</script></span> é a diferença máxima entre relógios, então após o uma mensagem ser enviada com timestamp <span><span class="MathJax_Preview">t</span><script type="math/tex">t</script></span>, até <span><span class="MathJax_Preview">\Delta</span><script type="math/tex">\Delta</script></span> depois, outro processo, atrasado em relação ao primeiro, poderá enviar uma mensagem com timestamp <span><span class="MathJax_Preview">t' &lt; t</span><script type="math/tex">t' < t</script></span>. Tal mensagem pode demorar até <span><span class="MathJax_Preview">\tau</span><script type="math/tex">\tau</script></span> para ser entregue à réplica, ou seja, no instante <span><span class="MathJax_Preview">t + \tau + \Delta</span><script type="math/tex">t + \tau + \Delta</script></span>, do ponto de vista do primeiro cliente.</p>
<p>Se a réplica estiver sincronizada com cliente, então se esperar até <span><span class="MathJax_Preview">t + \tau + \Delta</span><script type="math/tex">t + \tau + \Delta</script></span> para executar o comando, o fará de forma segura. Se estiver atrasada em relação ao primeiro cliente, então acabará por esperar além do necessário, mas sem violar a corretude do sistema.</p>
<p>Finalmente, se a réplica estiver adiantada em relação ao primeiro cliente, então seu relógio alcançará <span><span class="MathJax_Preview">t + \tau + \Delta</span><script type="math/tex">t + \tau + \Delta</script></span> antes do relógio do primeiro cliente, mas isso não é um problema. Isto porquê, o último instante em que o cliente 2 poderá enviar uma mensagem com timestamp <span><span class="MathJax_Preview">t' &lt; t</span><script type="math/tex">t' < t</script></span> é o instante em que o relógio da réplica marcar <span><span class="MathJax_Preview">t + \Delta</span><script type="math/tex">t + \Delta</script></span>, e portanto deverá também ser recebido até que o mesmo relógio marque <span><span class="MathJax_Preview">t + \tau + \Delta</span><script type="math/tex">t + \tau + \Delta</script></span>. </p>
<hr />
<h5 id="ordenacao-de-requisicoes_1">Ordenação de Requisições</h5>
<ul>
<li>Relógios <strong>dessincronizados</strong></li>
<li><span><span class="MathJax_Preview">\tau</span><script type="math/tex">\tau</script></span>.</li>
<li><span><span class="MathJax_Preview">\Delta</span><script type="math/tex">\Delta</script></span></li>
</ul>
<p><img alt="Ordenação" src="images/ordenacao2.png" /></p>
<p>O último instante em que qualquer mensagem com timestamp <span><span class="MathJax_Preview">t' &lt; t</span><script type="math/tex">t' < t</script></span> pode ser recebido pela réplica é <span><span class="MathJax_Preview">t+\tau + \Delta</span><script type="math/tex">t+\tau + \Delta</script></span>, pois qualquer mensagem recebida em <span><span class="MathJax_Preview">t''&gt; t+\tau + \Delta'</span><script type="math/tex">t''> t+\tau + \Delta'</script></span>, precisa ter sido enviada após <span><span class="MathJax_Preview">t+\Delta</span><script type="math/tex">t+\Delta</script></span>, e portanto terá timestamp <span><span class="MathJax_Preview">&gt; t</span><script type="math/tex">> t</script></span>. </p>
<hr />
<p>O mesmo raciocínio pode ser usado para definir um protocolo de acesso recursos para os quais <em>leases</em> são distribuídos, onde um <em>lease</em>  é uma permissão de acesso durante uma janela de tempo, emitida por um coordenador (possivelmente eleito usando os algoritmos vistos anteriormente), e <span><span class="MathJax_Preview">\Delta</span><script type="math/tex">\Delta</script></span> é o máximo de dessincronismo entre os relógios. 
O seguinte protocolo resolve este problema:</p>
<hr />
<h5 id="lease">Lease</h5>
<ul>
<li><span><span class="MathJax_Preview">\Delta</span><script type="math/tex">\Delta</script></span> - dessincronização máxima.</li>
<li>
<p>Ao receber um <em>lease</em> para a janela de tempo <span><span class="MathJax_Preview">t_1</span><script type="math/tex">t_1</script></span> a <span><span class="MathJax_Preview">t_2</span><script type="math/tex">t_2</script></span></p>
<ul>
<li>espera até <span><span class="MathJax_Preview">t_1 + \Delta</span><script type="math/tex">t_1 + \Delta</script></span></li>
<li>usa o recurso até <span><span class="MathJax_Preview">t_2</span><script type="math/tex">t_2</script></span>.</li>
</ul>
</li>
<li>
<p>Se relógio estiver adiantado em relação ao cliente anterior, vai achar que é <span><span class="MathJax_Preview">t_1+\Delta</span><script type="math/tex">t_1+\Delta</script></span> enquanto o anterior acha que é <span><span class="MathJax_Preview">t_1</span><script type="math/tex">t_1</script></span>; exclusão mútua garantida.</p>
</li>
<li>Se relógio estiver atrasado em relação ao cliente anterior, vai achar que é <span><span class="MathJax_Preview">t_1 - \Delta</span><script type="math/tex">t_1 - \Delta</script></span>, e continua esperando, enquanto ele acha que já é <span><span class="MathJax_Preview">t_1</span><script type="math/tex">t_1</script></span> e para de usar; exclusão mútua garantida.</li>
<li>Recurso fica ocioso por <span><span class="MathJax_Preview">\Delta</span><script type="math/tex">\Delta</script></span>, em média, a cada lease. </li>
</ul>
<hr />
<h2 id="devido-ao-alto-custo-de-se-manter-o-recurso-nao-utilizado-deltadelta-deve-ser-feito-tao-pequeno-quanto-possivel-leia-google-true-time-e-spanner-para-como-o-google-consegue-manter-a-diferenca-em-sub-milisegundos-usando-relogios-atomicos-dentro-de-seus-datacenters-e-um-api-para-geracao-de-timestamps">Devido ao alto custo de se manter o recurso não utilizado, <span><span class="MathJax_Preview">\Delta</span><script type="math/tex">\Delta</script></span> deve ser feito tão pequeno quanto possível. Leia <a href="https://cloud.google.com/spanner/docs/true-time-external-consistency">Google True Time e Spanner</a> para como o Google consegue manter a diferença em sub milisegundos, usando relógios atômicos dentro de seus datacenters e um API para geração de timestamps.</h2>
<p>layout: default
title: Tempo Lógico
parent: Tempo
nav_order: 2</p>
<hr />
<h1 id="relogio-logicos">Relógio Lógicos</h1>
<p>Nas soluções anteriores, um nó precisa esperar por muito tempo antes de usar um recurso. 
E se ele aprendesse antes que os outros nós não farão requisições? 
Que não haverão sobreposições de requisições? 
E se houvesse um relógio que avançasse não com o tempo, mas com eventos interessantes do sistema?
Esta é a ideia dos <strong>relógios lógicos</strong>.</p>
<hr />
<h6 id="relogios-logicos">Relógios Lógicos</h6>
<ul>
<li>Envio e recepção (e possivelmente outros eventos) fazem o relógio ``ticar''.</li>
<li>Processos podem usar este relógio para concordar na <strong>ordem</strong> dos eventos, mesmo que não no <strong>instante</strong> do evento.</li>
<li>Não há <strong>fonte da verdade</strong> em termos de tempo.</li>
<li>Cada processo mantém seu próprio relógio que pode ser relacionado com relógios de outros processos.</li>
</ul>
<p>Para chegarmos aos relógios lógicos, precisamos primeiro entender a relação <em>Happened-Before</em>, proposta por Leslie Lamport em <a href="http://amturing.acm.org/p558-lamport.pdf">Time, Clocks and the Ordering of Events in a Distributed System. July 5, 1978</a>, que lhe rendeu um <a href="https://www.microsoft.com/en-us/research/blog/leslie-lamport-receives-turing-award/">Prêmio Turing em 2014</a>.
Neste artigo, se estabelece o vocabulário para falar sobre ordem de eventos em um sistema computacional, em especial um distribuído.</p>
<hr />
<h5 id="happened-before">Happened-Before</h5>
<ul>
<li><span><span class="MathJax_Preview">a \rightarrow b</span><script type="math/tex">a \rightarrow b</script></span>: evento <span><span class="MathJax_Preview">a</span><script type="math/tex">a</script></span> aconteceu antes do evento <span><span class="MathJax_Preview">b</span><script type="math/tex">b</script></span></li>
<li>Considerando um único processo (thread):</li>
<li>Se <span><span class="MathJax_Preview">a</span><script type="math/tex">a</script></span> foi executado antes de <span><span class="MathJax_Preview">b</span><script type="math/tex">b</script></span> no processo, então <span><span class="MathJax_Preview">a \rightarrow b</span><script type="math/tex">a \rightarrow b</script></span>.</li>
<li>Considerando dois processos:</li>
<li>Se <span><span class="MathJax_Preview">a</span><script type="math/tex">a</script></span> é o envio de uma mensagem e <span><span class="MathJax_Preview">b</span><script type="math/tex">b</script></span> sua recepção, então <span><span class="MathJax_Preview">a \rightarrow b</span><script type="math/tex">a \rightarrow b</script></span>.</li>
<li>Transitividade faz sentido:</li>
<li>Se <span><span class="MathJax_Preview">a \rightarrow b</span><script type="math/tex">a \rightarrow b</script></span> e <span><span class="MathJax_Preview">b \rightarrow c</span><script type="math/tex">b \rightarrow c</script></span>, então <span><span class="MathJax_Preview">a \rightarrow c</span><script type="math/tex">a \rightarrow c</script></span></li>
</ul>
<hr />
<p>Esta relação captura a <strong>causalidade</strong> entre eventos. Isto é, se <span><span class="MathJax_Preview">a \rightarrow b</span><script type="math/tex">a \rightarrow b</script></span> então <span><span class="MathJax_Preview">a</span><script type="math/tex">a</script></span> potencialmente causou <span><span class="MathJax_Preview">b</span><script type="math/tex">b</script></span> (<span><span class="MathJax_Preview">a</span><script type="math/tex">a</script></span> precede <span><span class="MathJax_Preview">b</span><script type="math/tex">b</script></span> em uma ordem causal).
Note que se <span><span class="MathJax_Preview">a \rightarrow b</span><script type="math/tex">a \rightarrow b</script></span> é falso e <span><span class="MathJax_Preview">b \rightarrow a</span><script type="math/tex">b \rightarrow a</script></span> é falso, então <span><span class="MathJax_Preview">a</span><script type="math/tex">a</script></span> e <span><span class="MathJax_Preview">b</span><script type="math/tex">b</script></span> são <strong>concorrentes</strong>.</p>
<p>Se capturarmos a causalidade de eventos, podemos usar esta informação para ordenar o se processamento, de forma a fazer sentido.
Considere o seguinte exemplo:</p>
<p>TODO: Exemplo e emails com pergunta e respostas.</p>
<p>Para que computadores possam usar a causalidade, precisamos capturar a relação de acontecer antes em um sistema.
Lamport propôs uma tal forma, que denominou relógio lógico, mas que hoje é conhecido universalmente como Relógios de Lamport.
Estes relógios permitem associar um <em>timestamp</em> a eventos de forma a se garantir a seguinte propriedade:
* seja <span><span class="MathJax_Preview">e</span><script type="math/tex">e</script></span> um evento
* seja <span><span class="MathJax_Preview">C(e)</span><script type="math/tex">C(e)</script></span> o valor do relógio lógico quando associado a <span><span class="MathJax_Preview">e</span><script type="math/tex">e</script></span>
* se <span><span class="MathJax_Preview">a \rightarrow b</span><script type="math/tex">a \rightarrow b</script></span> então <span><span class="MathJax_Preview">C(a) &lt; C(b)</span><script type="math/tex">C(a) < C(b)</script></span></p>
<p>Mas como definir a função <span><span class="MathJax_Preview">C</span><script type="math/tex">C</script></span>?
Experimentemos a seguinte definição:
* Seja <span><span class="MathJax_Preview">c_p</span><script type="math/tex">c_p</script></span> um contador em <span><span class="MathJax_Preview">p</span><script type="math/tex">p</script></span> com valor inicialmente igual a 0.
* <span><span class="MathJax_Preview">C(e) = c++</span><script type="math/tex">C(e) = c++</script></span> no momento em que <span><span class="MathJax_Preview">e</span><script type="math/tex">e</script></span> ocorreu.
* Usamos como $ &lt; $ a relação normal de inteiros.
Assim, cada processo conta os eventos executados localmente.
Veja um exemplo desta definição em ação.</p>
<p>!(LC - Primeira tentativa)(imagess/lc_cont.png)</p>
<p>É verdade neste cenário que se <span><span class="MathJax_Preview">a \rightarrow b</span><script type="math/tex">a \rightarrow b</script></span> então <span><span class="MathJax_Preview">C(a) &lt; C(b)</span><script type="math/tex">C(a) < C(b)</script></span>?<br />
Observe com atenção os eventos <span><span class="MathJax_Preview">f</span><script type="math/tex">f</script></span> e <span><span class="MathJax_Preview">k</span><script type="math/tex">k</script></span>. Para estes, a regra não é respeitada.
Para que seja, precisamos garantir que, na recepção de uma mensagem, os contadores sejam atualizados para que sejam maiores tanto que os relógios dos eventos locais quanto dos eventos que antecederam o envio da mensagem sendo recebida.
Com este ajuste, temos os Relógios de Lamport.</p>
<h2 id="lamport-clock">Lamport Clock</h2>
<ul>
<li>Seja <span><span class="MathJax_Preview">c_p</span><script type="math/tex">c_p</script></span> um contador em <span><span class="MathJax_Preview">p</span><script type="math/tex">p</script></span> com valor inicialmente igual a 0.</li>
<li>Se o evento <span><span class="MathJax_Preview">e</span><script type="math/tex">e</script></span> é uma operação local, <span><span class="MathJax_Preview">C(e) = ++c</span><script type="math/tex">C(e) = ++c</script></span> no momento em que <span><span class="MathJax_Preview">e</span><script type="math/tex">e</script></span> ocorreu.</li>
<li>Se o evento <span><span class="MathJax_Preview">e</span><script type="math/tex">e</script></span> é o envio de uma mensagem, então <span><span class="MathJax_Preview">C(e)</span><script type="math/tex">C(e)</script></span> é enviado com a mensagem como seu timestamp.</li>
<li>Se o evento <span><span class="MathJax_Preview">e</span><script type="math/tex">e</script></span> é a recepção de uma mensagem com timestamp <span><span class="MathJax_Preview">ts</span><script type="math/tex">ts</script></span>, então <span><span class="MathJax_Preview">C(e) = max(c,ts)+1</span><script type="math/tex">C(e) = max(c,ts)+1</script></span>.</li>
</ul>
<p>!(LC - Primeira tentativa)(imagess/lc_lamport.png)</p>
<p>Neste caso, temos que para quaisquer eventos <span><span class="MathJax_Preview">a,b</span><script type="math/tex">a,b</script></span>,  se <span><span class="MathJax_Preview">a \rightarrow b</span><script type="math/tex">a \rightarrow b</script></span> então <span><span class="MathJax_Preview">C(a) &lt; C(b)</span><script type="math/tex">C(a) < C(b)</script></span>.</p>
<p>TODO: Exemplo em que não é bom o suficiente.</p>
<p>Se <span><span class="MathJax_Preview">a \rightarrow b</span><script type="math/tex">a \rightarrow b</script></span> então <span><span class="MathJax_Preview">C(a) &lt; C(b)</span><script type="math/tex">C(a) < C(b)</script></span>. Contudo, a volta não é verdade, isto é, se <span><span class="MathJax_Preview">C(a) &lt; C(b)</span><script type="math/tex">C(a) < C(b)</script></span> então <span><span class="MathJax_Preview">a \rightarrow b</span><script type="math/tex">a \rightarrow b</script></span>.
Esta propriedade é interessante na ordenação de eventos, pois evita que eventos concorrentes sejam ordenados.
Entram os relógios vetoriais.</p>
<h2 id="relogio-vetorial">Relógio vetorial</h2>
<p>Sejam <span><span class="MathJax_Preview">n</span><script type="math/tex">n</script></span> processos. No processo <span><span class="MathJax_Preview">p</span><script type="math/tex">p</script></span>
* Seja <span><span class="MathJax_Preview">c_p[i], 1 \leq i \leq n</span><script type="math/tex">c_p[i], 1 \leq i \leq n</script></span> um contador, inicialmente igual a 0.
* Se o evento <span><span class="MathJax_Preview">e</span><script type="math/tex">e</script></span> é uma operação local, <span><span class="MathJax_Preview">c_p[p]++</span><script type="math/tex">c_p[p]++</script></span> e <span><span class="MathJax_Preview">C(e) = c_p</span><script type="math/tex">C(e) = c_p</script></span> no momento em que <span><span class="MathJax_Preview">e</span><script type="math/tex">e</script></span> ocorreu.
* Se o evento <span><span class="MathJax_Preview">e</span><script type="math/tex">e</script></span> é o envio de uma mensagem, então <span><span class="MathJax_Preview">C(e)</span><script type="math/tex">C(e)</script></span> é enviado com a mensagem como seu timestamp.
* Se o evento <span><span class="MathJax_Preview">e</span><script type="math/tex">e</script></span> é a recepção de uma mensagem com timestamp <span><span class="MathJax_Preview">ts</span><script type="math/tex">ts</script></span> de <span><span class="MathJax_Preview">q</span><script type="math/tex">q</script></span>, então
  * <span><span class="MathJax_Preview">c_p[i] = max(c_p[i], ts[i]), i \neq p</span><script type="math/tex">c_p[i] = max(c_p[i], ts[i]), i \neq p</script></span>
  * <span><span class="MathJax_Preview">c_p[p]++</span><script type="math/tex">c_p[p]++</script></span>
  * <span><span class="MathJax_Preview">C(e) = c_p</span><script type="math/tex">C(e) = c_p</script></span></p>
<p>!(Relógio Vetorial)[images/lc_vc.png]</p>
<p>Como dito, este relógio lógico tem a seguinte propriedade: se <span><span class="MathJax_Preview">a \rightarrow b \RightLeftArrow C(a) &lt; C(b)</span><script type="math/tex">a \rightarrow b \RightLeftArrow C(a) < C(b)</script></span>.
Mas como é defido $ &lt; $ para vetores?
* <span><span class="MathJax_Preview">V = V' \iff V[i] = V'[i], 1 \leq i \leq n</span><script type="math/tex">V = V' \iff V[i] = V'[i], 1 \leq i \leq n</script></span>
* <span><span class="MathJax_Preview">V \leq V' \iff V[i] \leq V'[i], 1 \leq i \leq n</span><script type="math/tex">V \leq V' \iff V[i] \leq V'[i], 1 \leq i \leq n</script></span></p>
<p>Sejam dois eventos <span><span class="MathJax_Preview">e</span><script type="math/tex">e</script></span> e <span><span class="MathJax_Preview">e'</span><script type="math/tex">e'</script></span>
* Se <span><span class="MathJax_Preview">e \rightarrow e' \iff V(e) &lt; V(e')</span><script type="math/tex">e \rightarrow e' \iff V(e) < V(e')</script></span>
* Se <span><span class="MathJax_Preview">V(e) \not\leq V(e')</span><script type="math/tex">V(e) \not\leq V(e')</script></span> e <span><span class="MathJax_Preview">V(e') \not\leq V(e)</span><script type="math/tex">V(e') \not\leq V(e)</script></span>, são concorrentes.</p>
<p>Mas o que quer dizer <span><span class="MathJax_Preview">c_p[q] = k</span><script type="math/tex">c_p[q] = k</script></span>?
Quer dizer que <span><span class="MathJax_Preview">p</span><script type="math/tex">p</script></span> sabe que <span><span class="MathJax_Preview">q</span><script type="math/tex">q</script></span> enviou <span><span class="MathJax_Preview">k</span><script type="math/tex">k</script></span> mensagens.
E daí? O que pode ser feito com isso?<br />
Com estes mecanismos é possível implementar
* Multicast Totalmente Ordenado:
  * Multicast: mensagens são enviadas de 1 para n (comunicação em grupo)
  * Totalmente Ordenado: todos os processos entregam as mensagens na mesma ordem
* Multicast Causalmente Ordenado:
  * Causalmente Ordenado: uma mensagem só é entregue se todas as que causalmente a precedem já foram entregues.</p>
<p>Novamente você pergunta, e daí? Bem, com estas abstrações, podemos resolver problemas interessantes como o seguinte.
Considere um programa qualquer, que se comporte de forma determinística (isto é, dada uma mesma entrada, gera sempre uma mesma saída). Como todo programa, este é uma máquina de estados, com a peculiaridade de ser determinística.
Logo, se tivermos várias cópias deste programa, executando em locais distintos, mas garantirmos que cada cópia verá exatamente a mesma entrada de dados, então garantiremos que todas as cópias transitarão pelos mesmos estados e chegarão ao mesmo estado final.
Acontece que multicast totalmente ordenado pode garantir exatamente isso, que todas as cópias receberão a mesma entrada.</p>
<p>!(State Machine Replication)[images/06-11.png]</p>
<p>Esta técnica é conhecida como Replicação de Maáquinas de Estados (em inglês, (<em>State Machine Replication</em>)[<a href="https://en.wikipedia.org/wiki/State_machine_replication">https://en.wikipedia.org/wiki/State_machine_replication</a>]), ou pelo menos o seu princípio.</p>
<p>Mas como podemos implementar estas primitivas de multicast usando relógios lógicos?
Considere o seguinte algoritmo.</p>
<hr />
<h6 id="multicast-totalmente-ordenado">Multicast totalmente ordenado</h6>
<ul>
<li>Fila com prioridade em cada processo.</li>
<li>Mensagens são enviadas a todos os processos e colocadas em uma fila local.</li>
<li>Mensagens recebidas são colocadas na fila local e ack é enviado de volta.</li>
<li><span><span class="MathJax_Preview">p</span><script type="math/tex">p</script></span> só entrega uma mensagem <span><span class="MathJax_Preview">m</span><script type="math/tex">m</script></span> recebida de <span><span class="MathJax_Preview">q</span><script type="math/tex">q</script></span>, com timestamp <span><span class="MathJax_Preview">ts</span><script type="math/tex">ts</script></span> quando</li>
<li><span><span class="MathJax_Preview">m</span><script type="math/tex">m</script></span> está na cabeça da fila de <span><span class="MathJax_Preview">p</span><script type="math/tex">p</script></span></li>
<li>Para cada processo <span><span class="MathJax_Preview">q</span><script type="math/tex">q</script></span>, há uma mensagem <span><span class="MathJax_Preview">m'</span><script type="math/tex">m'</script></span> de <span><span class="MathJax_Preview">q</span><script type="math/tex">q</script></span>, <span><span class="MathJax_Preview">ts'</span><script type="math/tex">ts'</script></span>, na fila de <span><span class="MathJax_Preview">p</span><script type="math/tex">p</script></span> tal <span><span class="MathJax_Preview">ts &lt; ts'</span><script type="math/tex">ts < ts'</script></span></li>
<li>Canais confiáveis e FIFO.</li>
</ul>
<hr />
<hr />
<h6 id="multicast-causalmente-ordenado">Multicast causalmente ordenado</h6>
<ul>
<li>Mensagens são enviadas a todos os processos.</li>
<li><span><span class="MathJax_Preview">p</span><script type="math/tex">p</script></span> incrementa <span><span class="MathJax_Preview">c_p[p]</span><script type="math/tex">c_p[p]</script></span> somente no envio de mensagens.</li>
<li><span><span class="MathJax_Preview">p</span><script type="math/tex">p</script></span> só entrega uma mensagem recebida de <span><span class="MathJax_Preview">q</span><script type="math/tex">q</script></span>, com timestamp <span><span class="MathJax_Preview">ts</span><script type="math/tex">ts</script></span> quando</li>
<li><span><span class="MathJax_Preview">ts[q] = c_p[q]+1</span><script type="math/tex">ts[q] = c_p[q]+1</script></span></li>
<li><span><span class="MathJax_Preview">ts[k] \leq c_p[k], k \neq q</span><script type="math/tex">ts[k] \leq c_p[k], k \neq q</script></span></li>
</ul>
<p>\includegraphics[width=.5\textwidth]{images/06-13}</p>
<p>Considere <span><span class="MathJax_Preview">c_{P_2}[0,2,2]</span><script type="math/tex">c_{P_2}[0,2,2]</script></span> e <span><span class="MathJax_Preview">ts=[1,3,0]</span><script type="math/tex">ts=[1,3,0]</script></span>, de <span><span class="MathJax_Preview">P_0</span><script type="math/tex">P_0</script></span>. O que <span><span class="MathJax_Preview">P_2</span><script type="math/tex">P_2</script></span> está esperando? Como age ao receber mensagem com <span><span class="MathJax_Preview">ts</span><script type="math/tex">ts</script></span>?</p>
<hr />
<h2 id="exclusao-mutua-revisitada">Exclusao Mútua Revisitada</h2>
<p>Retorno à exclusão mútua</p>
<p>TODO: (Algoritmos de Excluão mútua baeados em LC)[<a href="http://www.cs.cmu.edu/~dga/15-440/F10/lectures/Distributed-Mutual-Exclusion-slides.pdf">http://www.cs.cmu.edu/~dga/15-440/F10/lectures/Distributed-Mutual-Exclusion-slides.pdf</a>]</p>
<p>TODO: Algoritmo de Lamport, Ricart e agrawalla</p>
<p>TODO: Algoritmo de (Maekawa)[<a href="https://www.coursera.org/learn/cloud-computing-2/lecture/GMHYN/2-4-maekawas-algorithm-and-wrap-up">https://www.coursera.org/learn/cloud-computing-2/lecture/GMHYN/2-4-maekawas-algorithm-and-wrap-up</a>]</p>
<h2 id="relogios-hibridos">Relógios Híbridos</h2>
<p>TODO: (Google TrueTime)[<a href="https://cloud.google.com/spanner/docs/true-time-external-consistency">https://cloud.google.com/spanner/docs/true-time-external-consistency</a>)</p>
<h2 id="hibrid-logical-clocks">Hibrid Logical Clocks</h2>
<p>!(Hibrid Logical Clock)[images/lc_hybrid]</p>
<p>Onde se lê 3,13, leia-se 3,10,3.</p>
<p>(Fonte)(<a href="http://muratbuffalo.blogspot.com.br/2014/07/hybrid-logical-clocks.html">http://muratbuffalo.blogspot.com.br/2014/07/hybrid-logical-clocks.html</a>)</p>
<h2 id="interceptadores">Interceptadores</h2>
<p>!(Transparente para a aplicação)[images/06-10]</p>
                
                  
                
              
              
                


              
            </article>
          </div>
        </div>
      </main>
      
        
<footer class="md-footer">
  
    <div class="md-footer-nav">
      <nav class="md-footer-nav__inner md-grid" aria-label="Footer">
        
          <a href="../coord/" title="Coordenação" class="md-footer-nav__link md-footer-nav__link--prev" rel="prev">
            <div class="md-footer-nav__button md-icon">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20,11V13H8L13.5,18.5L12.08,19.92L4.16,12L12.08,4.08L13.5,5.5L8,11H20Z" /></svg>
            </div>
            <div class="md-footer-nav__title">
              <div class="md-ellipsis">
                <span class="md-footer-nav__direction">
                  Previous
                </span>
                Coordenação
              </div>
            </div>
          </a>
        
        
          <a href="../fault/" title="Tolerância a Falhas" class="md-footer-nav__link md-footer-nav__link--next" rel="next">
            <div class="md-footer-nav__title">
              <div class="md-ellipsis">
                <span class="md-footer-nav__direction">
                  Next
                </span>
                Tolerância a Falhas
              </div>
            </div>
            <div class="md-footer-nav__button md-icon">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M4,11V13H16L10.5,18.5L11.92,19.92L19.84,12L11.92,4.08L10.5,5.5L16,11H4Z" /></svg>
            </div>
          </a>
        
      </nav>
    </div>
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-footer-copyright">
        
        Made with
        <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
          Material for MkDocs
        </a>
      </div>
      
    </div>
  </div>
</footer>
      
    </div>
    
      <script src="../assets/javascripts/vendor.c51dfa35.min.js"></script>
      <script src="../assets/javascripts/bundle.eaaa3931.min.js"></script><script id="__lang" type="application/json">{"clipboard.copy": "Copy to clipboard", "clipboard.copied": "Copied to clipboard", "search.config.lang": "en", "search.config.pipeline": "trimmer, stopWordFilter", "search.config.separator": "[\\s\\-]+", "search.result.placeholder": "Type to start searching", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents"}</script>
      
      <script>
        app = initialize({
          base: "..",
          features: [],
          search: Object.assign({
            worker: "../assets/javascripts/worker/search.58d22e8e.min.js"
          }, typeof search !== "undefined" && search)
        })
      </script>
      
        <script src="https://unpkg.com/mermaid@8.5.1/dist/mermaid.min.js"></script>
      
        <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
      
    
  </body>
</html>